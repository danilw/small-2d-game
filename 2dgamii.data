#version 300 es
#ifdef GL_ES
 precision highp float;
#endif
uniform float rot;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_texture1;
uniform float u_time;
uniform vec2 pos;
out vec4 glFragColor;

#define iTime u_time
#define iResolution u_resolution
#define iChannel0 u_texture1
#define iMouse u_mouse

// License Creative Commons Attribution-NonCommercial-ShareAlike
// original source github.com/danilw

vec4 getScene(vec2 fc)
{
    vec2 uv=fc/iResolution;
    return texture(iChannel0,uv);
}


void main() {
    glFragColor=getScene(vec2(gl_FragCoord.x,gl_FragCoord.y));
//glFragColor=vec4(1.,0.,0.,0.5);
}
#version 300 es
#ifdef GL_ES
 precision highp float;
#endif
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_texture1;
uniform float u_time;
out vec4 glFragColor;

#define iTime u_time
#define iResolution u_resolution
#define iChannel0 u_texture1
#define iMouse u_mouse

// License Creative Commons Attribution-NonCommercial-ShareAlike
// original source github.com/danilw
vec3 sun( vec2 uv, vec2 p ) 
{
    vec3 res;
    vec2 resx = iResolution.xy / iResolution.y;
    float di = distance(uv, p);
    res.x =  di <= .23333 ? sqrt(1. - di*3.) : 0.;
    
    res.x =  1.;
    
    res.yz = p;

    res.yz = res.yz/resx+0.5;
    
    return res;
}

float circle( vec2 pos, float r, vec2 uv )
{
    return distance(uv, pos) < r ? 1. : 0.;
}

float map(vec2 uv)
{
	vec2 res = iResolution.xy / iResolution.y;
    float occluders = 0.;
    vec3 texturex=texture(iChannel0,uv/res+0.5).rgb;
    occluders=max(occluders,smoothstep(0.,0.1,max(max(texturex.r,texturex.g),texturex.b))); //for colors
    return (occluders);
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 res = iResolution.xy / iResolution.y;
    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;
    
    vec3 light = min(sun(uv, vec2(0.0, 0.0)), vec3(1.));
    float occluders = map(uv);
    float col = max(light.x - occluders, 0.);
        
    fragColor = vec4(col,occluders,light.yz);
}

void main() {
	vec4 ret;
	mainImage(ret,gl_FragCoord.xy);
	glFragColor=ret;
}
#version 300 es
in vec4 position;
void main() {
  gl_Position = vec4(position.xyz,1.);
}
#version 300 es
#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_texture1;
uniform sampler2D u_texture2;
uniform float u_time;
uniform int QUALITY;
out vec4 glFragColor;
uniform float ppower;
uniform float ppowerhitr;
uniform vec2 xshape_size;
uniform vec2 xshape_pos;

#define iTime u_time
#define iResolution u_resolution
#define iChannel0 u_texture1
#define iChannel1 u_texture2
#define iMouse u_mouse

// License Creative Commons Attribution-NonCommercial-ShareAlike
// original source github.com/danilw

#define DECAY  .974
#define EXPOSURE .24

int SAMPLES = 8;
float DENSITY = .8;
float WEIGHT = .38;
float ilval = 1.5;

#define iterBayerMat 1
#define bayer2x2(a) (4-(a).x-((a).y<<1))%4
//return bayer matris (bitwise operands for speed over compatibility)

float GetBayerFromCoordLevel(vec2 pixelpos) {
    ivec2 p = ivec2(pixelpos);
    int a = 0
            ;
    for (int i = 0; i < iterBayerMat; i++
            ) {
        a += bayer2x2(p >> (iterBayerMat - 1 - i)&1) << (2 * i);
    }
    return float(a) / float(2 << (iterBayerMat * 2 - 1));
}

float bayer2(vec2 a) {
    a = floor(a);
    return fract(dot(a, vec2(.5, a.y * .75)));
}

float bayer4(vec2 a) {
    return bayer2(.5 * a)*.25 + bayer2(a);
}

float bayer8(vec2 a) {
    return bayer4(.5 * a)*.25 + bayer2(a);
}

float bayer16(vec2 a) {
    return bayer4(.25 * a)*.0625 + bayer4(a);
}

float bayer32(vec2 a) {
    return bayer8(.25 * a)*.0625 + bayer4(a);
}

float bayer64(vec2 a) {
    return bayer8(.125 * a)*.015625 + bayer8(a);
}

float bayer128(vec2 a) {
    return bayer16(.125 * a)*.015625 + bayer8(a);
}
#define dither2(p)   (bayer2(  p)-.375      )
#define dither4(p)   (bayer4(  p)-.46875    )
#define dither8(p)   (bayer8(  p)-.4921875  )
#define dither16(p)  (bayer16( p)-.498046875)
#define dither32(p)  (bayer32( p)-.499511719)
#define dither64(p)  (bayer64( p)-.49987793 )
#define dither128(p) (bayer128(p)-.499969482)

float iib(vec2 u) {
    return dither128(u); //analytic bayer, base2
    return GetBayerFromCoordLevel(u * 999.); //iterative bayer 
    //optionally: instad just use bitmap of a bayer matrix: (LUT approach)
    //return texture(iChannel1,u/iChannelResolution[1].xy).x;
}

void init() {
    if (QUALITY == 1) {
        SAMPLES = 16;
        DENSITY = .93;
        WEIGHT = .38;
        ilval = .8;
    } else
        if (QUALITY == 3) {
        SAMPLES = 64;
        DENSITY = .97;
        WEIGHT = .25;
        ilval = .4;
    } else
        if (QUALITY == 2) {
        SAMPLES = 32;
        DENSITY = .95;
        WEIGHT = .25;
        ilval = .67;
    } else {
        SAMPLES = 8;
        DENSITY = .8;
        WEIGHT = .38;
        ilval = 1.35;
    }

}

vec3 textured_col(vec2 uv) {
    return texture(iChannel1, uv).rgb;
}

float dist(in vec2 uv, in vec2 p, in float level) {
    float h = level;
    uv = pow(abs(uv - p), vec2(h));
    return pow(uv.x + uv.y, 1. / h);
}

vec4 star(vec2 xy, vec2 point) {

    // Color
    vec3 col = vec3(0.0);
    float speed = 20.0;
    //point=vec2(0.);
    col = mix(vec3(0.0), vec3((sin(iTime / 2.) * 0.5 + 0.65), 0.5, 1.0), 2.0 / dist(xy, point, 5.0 * (0.5 * sin(iTime) + 0.55)) / 5.0);

    // Output to screen
    return vec4(col, 1.0);
}

#define PI (4.0 * atan(1.0))
#define TWO_PI PI*2.

const vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);
const vec3 dark = vec3(0x1a, 0x13, 0x21) / float(0xff);

const vec3 green = vec3(0x7f, 0xbe, 0x20) / float(0xff);
const vec3 green_l = vec3(0x92, 0xdb, 0x26) / float(0xff);

const vec3 ground1 = vec3(0xce, 0x98, 0x69) / float(0xff);
const vec3 ground2 = vec3(0xca, 0x8f, 0x5b) / float(0xff);
const vec3 ground3 = vec3(0xc1, 0x7f, 0x41) / float(0xff);

float circle(in vec2 uv, float r1, float r2, bool disk) {
    float w = 2.0 * fwidth(uv.x);
    float t = r1 - r2;
    float r = r1;

    if (!disk)
        return smoothstep(-w / 2.0, w / 2.0, abs(length(uv) - r) - t / 2.0);
    else
        return smoothstep(-w / 3.0, w / 3.0, (length(uv) - r));

}

float shape_CIRCLE(vec2 p, float r) {
    return length(p) - r + 0.5;
}

vec4 mi_sunwbg(vec2 uv) {
    float rayCount = 12.25;
    vec3 color1 = white * 1.5;
    vec3 color2 = dark;
    vec2 c = uv;
    c *= 1.;
    //c+=vec2(-0.2,-0.2);
    float iTime = iTime * 0.00152 + 0.018 * sin(iTime * 0.152);

    float angle = atan(c.y, c.x);
    float dist = length(c);

    angle /= (2. * PI);
    float mask = 1.;

    float distRound = (1.65 - ceil(dist * rayCount * .5 + .25)*.1);

    float time2 = (fract((dist) * rayCount * .5 + .25) > 0.5 ? -iTime : iTime) * (rayCount * 2. + 2. * distRound);
    float ngfract = fract(angle * round(rayCount / (distRound * distRound)) + time2 * .6);
    ngfract = abs(ngfract * 2. - 1.);
    ngfract *= fract(dist * rayCount) > .5 ? -1. : 1.;
    mask -= ceil(dist * rayCount + .5 + ngfract * .5)*.1;



    float b = 1. - circle(uv + vec2(0., 0.), 0.2242, 0.22, true);
    return vec4(max(dark, mix(vec3(0.5 * mix(vec3(.17, .0, .9)*.3, mix(color2, color1, mask), distRound))
            * smoothstep(01., 0.4, length(c)), white, b)), 1.);
}




// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

#define res_          iResolution
#define time_         iTime
#define detail_steps_ 13

#define mod3_      vec3(.1031, .11369, .13787)

vec3 hash3_3(vec3 p3) {
    p3 = fract(p3 * mod3_);
    p3 += dot(p3, p3.yxz + 19.19);
    return -1. + 2. * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));
}

float perlin_noise3(vec3 p) {
    vec3 pi = floor(p);
    vec3 pf = p - pi;

    vec3 w = pf * pf * (3. - 2. * pf);

    return mix(
            mix(
            mix(
            dot(pf - vec3(0, 0, 0), hash3_3(pi + vec3(0, 0, 0))),
            dot(pf - vec3(1, 0, 0), hash3_3(pi + vec3(1, 0, 0))),
            w.x),
            mix(
            dot(pf - vec3(0, 0, 1), hash3_3(pi + vec3(0, 0, 1))),
            dot(pf - vec3(1, 0, 1), hash3_3(pi + vec3(1, 0, 1))),
            w.x),
            w.z),
            mix(
            mix(
            dot(pf - vec3(0, 1, 0), hash3_3(pi + vec3(0, 1, 0))),
            dot(pf - vec3(1, 1, 0), hash3_3(pi + vec3(1, 1, 0))),
            w.x),
            mix(
            dot(pf - vec3(0, 1, 1), hash3_3(pi + vec3(0, 1, 1))),
            dot(pf - vec3(1, 1, 1), hash3_3(pi + vec3(1, 1, 1))),
            w.x),
            w.z),
            w.y);
}

float noise_sum_abs3(vec3 p) {
    float f = 0.;
    p = p * 3.;
    f += 1.0000 * abs(perlin_noise3(p));
    p = 2. * p;
    f += 0.5000 * abs(perlin_noise3(p));
    p = 3. * p;
    f += 0.2500 * abs(perlin_noise3(p));
    p = 4. * p;
    f += 0.1250 * abs(perlin_noise3(p));
    p = 5. * p;
    f += 0.0625 * abs(perlin_noise3(p));
    p = 6. * p;

    return f;
}

vec4 mi_expl(vec2 p) {
    //p*=4.2;

    float electric_density = .9;
    float electric_radius = length(p) - .4;

    float moving_coord = iTime / 15.; //+sin(velocity * time_) / .2 * cos(velocity * time_)
    vec3 electric_local_domain = vec3(p, moving_coord);
    float electric_field = electric_density * noise_sum_abs3(electric_local_domain);

    vec3 col = vec3(107, 148, 196) / 255.;
    col += (1. - (electric_field + electric_radius));

    col += 1. - 4.2 * electric_field;
    col = min(vec3(1.),max(vec3(0.), col));

    float alpha = 1.;
    return vec4(col, alpha);
}

vec4 exlp(vec2 uv) {
    if (ppowerhitr < 0.1)return vec4(0.);
    vec2 res = iResolution.xy / iResolution.y;
    uv += (xshape_pos.xy) / iResolution.y - res / 2.; //to box2d coords
    uv *= iResolution.y / xshape_size.y;
    float ce = shape_CIRCLE(uv, .5);
    ce = (smoothstep(0.0, 0.012, (ce - 0.5)));
    return ppowerhitr * ce * mi_expl(uv);
}

vec3 saturate(vec3 a) {
    return clamp(a, 0., 1.);
}

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float xRandom(float x) {
    return mod(x * 7241.6465 + 2130.465521, 64.984131);
}

float hash2(in vec2 p) {
    return fract(dot(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));
}

float hash(vec2 p) {
    vec2 pos = fract(p / 128.) * 128. + vec2(-64.340622, -72.465622);
    return fract(dot(pos.xyx * pos.xyy, vec3(20.390625, 60.703125, 2.4281209)));
}

float noise(float y, float t) {
    vec2 fl = vec2(floor(y), floor(t));
    vec2 fr = vec2(fract(y), fract(t));
    float a = mix(hash(fl + vec2(0.0, 0.0)), hash(fl + vec2(1.0, 0.0)), fr.x);
    float b = mix(hash(fl + vec2(0.0, 1.0)), hash(fl + vec2(1.0, 1.0)), fr.x);
    return mix(a, b, fr.y);
}

float noise2(float y, float t) {
    vec2 fl = vec2(floor(y), floor(t));
    vec2 fr = vec2(fract(y), fract(t));
    float a = mix(hash2(fl + vec2(0.0, 0.0)), hash2(fl + vec2(1.0, 0.0)), fr.x);
    float b = mix(hash2(fl + vec2(0.0, 1.0)), hash2(fl + vec2(1.0, 1.0)), fr.x);
    return mix(a, b, fr.y);
}

float line(vec2 uv, float width, float center) {
    float b = (1. - smoothstep(.0, width / 2., (uv.y - center)))*1.; //abs
    float b2 = (1. - smoothstep(.0, 5. * width, (uv.y - center)))*.8; //abs
    return b; //+b2;
}



const vec3 red = vec3(0xa6, 0x36, 0x2c) / float(0xff);
const vec3 redw = vec3(0xfd, 0x8c, 0x77) / float(0xff);

#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))
float animstart = 2.5;

vec3 strucb(vec2 uv) {
    float d = step(-0.14, uv.y) * step(uv.y, -0.127) * step(abs(uv.x + 0.19), 0.02);
    vec3 ret = vec3(0.);
    d = max(d, step(-0.14, uv.y)*(1. - circle(uv + vec2(0.225, 0.14), 0.02270, 0.35, true)));
    d = max(d, step(-0.14, uv.y)*(1. - circle(uv + vec2(0.165, 0.14), 0.02970, 0.35, true)));
    d = max(d, step(uv.y, -0.094) * step(-0.14, uv.y) * smoothstep(0.0031, 0.0008, abs(uv.x + 0.12)));
    d = max(d, step(uv.y, -0.115) * step(-0.14, uv.y) * smoothstep(0.0031, 0.0008, abs(uv.x + 0.1075)));
    ret = d*red;
    float tuvx = mod(uv.x, 0.006) - 0.003;
    d = step(-0.132, uv.y);
    d = step(abs(uv.x + 0.225), 0.015) * d * smoothstep(0.0031, 0.0005, abs(tuvx))*(1. - circle(uv + vec2(0.225, 0.143), 0.021970, 0.35, true));
    ret = mix(ret, redw * 1.25, d);
    tuvx = mod(uv.x - 0.093, 0.012) - 0.006;
    d = smoothstep(0.0061, 0.0035, abs(tuvx)) * step(abs(uv.y + 0.122), 0.00182);
    ret = mix(ret, white, d * step(abs(uv.x + 0.165), 0.0165));
    return ret * smoothstep(animstart + 2.2, animstart + 3.2, iTime); //anim sruct

}

vec3 postfx(vec2 uv, vec3 col, float reg) {
    vec3 ret = col + 1.5 * reg * ((rand(uv) - .5)*.07);
    ret = saturate(1.5 * ret);
    return ret;
}
#define PI (4.0 * atan(1.0))
#define TWO_PI PI*2.

float animendfade() {
    return smoothstep(animstart + 11.5, animstart + 9.5, iTime);
}

float animendfades() {
    return step(animstart + 9.5, iTime);
}

vec3 map(vec2 uv, float lt) {
    float d = (circle(uv, 0.32 * smoothstep(animstart - 1., animstart + 0.35, iTime), 0., true));

    vec3 tcol = d*dark;
    float a = 1. - circle(uv, 0.3542, 0.35, false);
    vec2 tuv = uv;
    float af = atan(tuv.x, tuv.y);
    float r = length(tuv)*0.75;
    tuv = vec2(af / TWO_PI, r);
    a *= step(tuv.x, -PI / 2. + PI * smoothstep(animstart + 2.5, animstart + 4.8, iTime)); //anim circle
    vec3 ret = max(tcol, a * (1. - lt) * redw);
    ret = max(ret, lt * dark);
    ret = max(ret, (1. - lt)*(1. - d) * red) * smoothstep(animstart - 1., animstart + 0.35, iTime);
    float b = 1. - circle(uv + vec2(0., 0.225 * smoothstep(animstart, animstart - 2., iTime)), 0.2242, 0.22, true);
    tuv = uv;
    //tuv*=MD(-0.05-0.2*smoothstep(-0.25,0.85,uv.x));;
    //tuv.y+= ((cos(.85*tuv.x))-.975);
    float tuvy = mod(tuv.y, 0.015) - 0.0075;
    float e = 1. - max(smoothstep(0.0005, 0.0031, abs(tuvy)), step(0.195, tuv.y) + step(tuv.y, 0.185) * step(0.165, tuv.y) +
            step(tuv.y, 0.14) * step(0.06, tuv.y) + step(tuv.y, 0.03) * step(0.015, tuv.y));
    //anim 1
    /*float di=floor(animstart+iTime*1.5); //anim
    di+=di>1.?1.:0.;
    di+=di>4.?5.:0.;
    di+=di>11.?1.:0.;
    float ir=mod(animstart+iTime*1.5,1.); //anim
    e*=1.-(max(step((-uv.y+di*(1.*0.015)+0.0075),0.0075),
           step(ir-0.5,uv.x)*step(abs(uv.y-di*(1.*0.015)+0.0075),0.0075)));*/

    //anim 2
    float di = smoothstep(animstart + 4.5, animstart + 6.5, iTime); //anim
    float di2 = smoothstep(animstart + 8.5, animstart + 9.5, iTime);
    e *= step(uv.x + 1.5 * uv.y * (1. - di), di - 0.5);
    e *= step(di2 - .5, uv.x - 2. * uv.y * (1. - di2));

    e = (1. - e)*(b);
    ret = max(ret, (1. - lt) * e * white);
    float c = 1. - circle(uv, 0.3542, 0.35, true);
    tuvy = (mod(uv.y, 0.026 + 0.1 * smoothstep(-.5, 0.5, uv.y)) - 0.013 - 0.05 * smoothstep(-.5, 0.5, uv.y));
    e = smoothstep(0.001, 0.0051, abs(tuvy));
    e = ((step(uv.y, -0.109)) * c * (1. - e * step(uv.y, -0.109)));
    e *= step(abs(uv.x), 0.5 * smoothstep(animstart + 1.5, animstart + 3., iTime)); //anim bot lines
    ret = max(ret, red * e);
    tuv = uv;
    tuv *= MD(3.3 - sin(01.0 - cos(2.0 * smoothstep(animstart + 4.25, animstart + 5.5, iTime)))); //anim pl2
    tuv += vec2(0.35521, 0.);
    float f = 1. - circle(tuv, 0.0270, 0.35, true);
    ret = max(ret, f * redw * (1. - lt));
    tuv = uv;
    tuv *= MD(-0.3 + 01. * smoothstep(animstart + 2., animstart + 4.8, iTime));
    tuv += vec2(0.2242, 0.);
    //float fa=f;
    f = 1. - circle(tuv, 0.0570, 0.35, true);
    ret = max(ret * (1. - (1. - lt) * f), (1. - lt) * f * dark * (1. - lt));
    ret = max(ret, strucb(uv));
    //ret=postfx(uv,ret,max(c,fa));
    f *= animendfade();
    return max(dark, max(ret * animendfade(),
            max((1. - f) * b * white * (1. - animendfade()), max((1. - f) * b * white * (1. - lt) * animendfades(),
            (1. - f) * b * white * (lt)*(1. - animendfade()))))); //anim
}

float animm() {
    return smoothstep(animstart, animstart + 1.5, iTime);
}

vec4 mi_anim(in vec2 uv) {
    float Range = 10.;
    //anim
    float Line_Smooth = animm() *
            pow(smoothstep(Range, Range - .05, 2. * Range * (abs(smoothstep(.0, Range, uv.x + .5) - .5))), .2);


    float rndx = iTime;
    rndx = 100.;
    rndx *= 20.;
    float Factor_T = floor(rndx);
    float Factor_X = xRandom(uv.x * .0021);
    float Amplitude1 = 0.5000 * noise(Factor_X, Factor_T)
            + 0.2500 * noise(Factor_X, Factor_T)
            + 0.1250 * noise(Factor_X, Factor_T)
            + 0.0625 * noise(Factor_X, Factor_T);
    Factor_X = xRandom(uv.x * .0031 + .0005);
    float Amplitude2 = 0.5000 * noise2(Factor_X, Factor_T)
            + 0.2500 * noise2(Factor_X, Factor_T)
            + 0.1250 * noise2(Factor_X, Factor_T)
            + 0.0625 * noise2(Factor_X, Factor_T);

    vec2 p = uv;
    p.y += ((cos(.5 * p.x - 0.15)) - .975) * animm(); //anim
    float Light_Track = line(vec2(p.x, p.y * 2. + (Amplitude2 - .5)*.12 * Line_Smooth), .005, .0);
    float Light_Track2 = line(vec2(uv.x, uv.y + (Amplitude2 - .5)*.16 * Line_Smooth), .005, .0);

    vec3 line1 = Light_Track*dark;
    //vec4 line2 =  vec4(Light_Track2)*Light_Color2;

    vec3 retcol = vec3(0.);
    retcol = map(uv, Light_Track);
    return vec4(retcol, 1.);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    init();
    vec2 uv = fragCoord.xy / iResolution.xy;

    vec2 coord = uv;
    vec2 res = iResolution.xy / iResolution.y;
    vec2 tuv = (fragCoord.xy) / iResolution.y - res / 2.0;
    vec2 lightpos = texture(iChannel0, uv).zw;

    float occ = texture(iChannel0, uv).x; //light
    float obj = texture(iChannel0, uv).y; //objects
    vec3 obj_col = textured_col(uv);
    //fragColor = vec4(obj);return;
    float dither = iib(fragCoord);

    vec2 dtc = (coord - lightpos) * (1. / float(SAMPLES) * DENSITY);
    float illumdecay = ilval;

    if (QUALITY + 1 > 0) {
        for (int i = 0; i < SAMPLES; i += 4) {
            coord -= dtc;
            float s = texture(iChannel0, coord + (dtc * dither)).x;
            coord -= dtc;
            s += texture(iChannel0, coord + (dtc * dither)).x;
            coord -= dtc;
            s += texture(iChannel0, coord + (dtc * dither)).x;
            coord -= dtc;
            s += texture(iChannel0, coord + (dtc * dither)).x;
            s *= illumdecay * WEIGHT;
            occ += s;
            illumdecay *= DECAY;
        }

        //fragColor = vec4(vec3(0., 0., obj * .6333) + occ*EXPOSURE/1., 1.0)/1.;
        //fragColor = vec4(mix(obj.rgb*objx,vec3(1.),occ*EXPOSURE/1.), 1.0);

        fragColor = obj * vec4((obj_col + smoothstep(.85, .0, length(tuv)) * vec3(.78) * occ * EXPOSURE / 1.), 1.0);
        //fragColor+=(1.-obj)*mi_sunwbg(tuv);
        fragColor += (1. - obj) * mi_sunwbg(tuv) * occ * EXPOSURE / 1.;
        //fragColor= (fragColor)*star(tuv, vec2(0.15, -0.25+0.2*sin(iTime/2.)));
        
        
    } else {
        fragColor = max((mi_sunwbg(tuv)*(1. - obj)), vec4(obj_col, 1.));
    }

    fragColor = abs(fragColor);
    fragColor += clamp(vec4(1.),vec4(0.),abs(exlp(tuv)));
    if (iTime <= 15.) {
		fragColor =mi_anim(tuv);
    }else
    if (iTime <= 15.+ 8. + 2.) {
        vec3 oc = mix(dark, white, 1. - circle(tuv + vec2(0., 0.), 0.2242, 0.22, true));
        float ce = shape_CIRCLE(tuv, 2. * smoothstep(15.+ 8. + 0., 15.+ 8. + 2., iTime));
        ce = 1. - (smoothstep(0.0, 0.012, (ce - 0.5)));
        fragColor.rgb *= ce;
        fragColor.rgb = max(fragColor.rgb, (1. - obj) *oc.rgb+obj_col);
    }
    fragColor.a = 1.;
    //fragColor=vec4(obj);
}

void main() {
    vec4 ret;
    mainImage(ret, gl_FragCoord.xy);
    glFragColor = ret;
}
#version 300 es
#ifdef GL_ES
 precision highp float;
#endif
uniform float rot;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_texture1;
uniform float u_time;
uniform vec2 pos;
out vec4 glFragColor;

#define iTime u_time
#define iResolution u_resolution
#define iChannel0 u_texture1
#define iMouse u_mouse

// FXAA with some defines in front and bootstrapping at the end :)
//  Also replaced some texture lookup functions in the FXAA code in order to
//  please some shader compilers.

// NOTE: This shader has issues with some GL versions. If this is the case,
//  this shader can be disabled by uncommenting the following line (disabling
//  anti-aliasing altogether):
//#define NO_FXAA

#ifndef NO_FXAA

#define FXAA_PC 1
#define FXAA_GLSL_130 1
#define FXAA_QUALITY__PRESET 39

/*============================================================================


                    NVIDIA FXAA 3.11 by TIMOTHY LOTTES


------------------------------------------------------------------------------
COPYRIGHT (C) 2010, 2011 NVIDIA CORPORATION. ALL RIGHTS RESERVED.
------------------------------------------------------------------------------
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL NVIDIA
OR ITS SUPPLIERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR
CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR
LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION,
OR ANY OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE
THIS SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

------------------------------------------------------------------------------
                           INTEGRATION CHECKLIST
------------------------------------------------------------------------------
(1.)
In the shader source, setup defines for the desired configuration.
When providing multiple shaders (for different presets),
simply setup the defines differently in multiple files.
Example,

  #define FXAA_PC 1
  #define FXAA_HLSL_5 1
  #define FXAA_QUALITY__PRESET 12

Or,

  #define FXAA_360 1
  
Or,

  #define FXAA_PS3 1
  
Etc.

(2.)
Then include this file,

  #include "Fxaa3_11.h"

(3.)
Then call the FXAA pixel shader from within your desired shader.
Look at the FXAA Quality FxaaPixelShader() for docs on inputs.
As for FXAA 3.11 all inputs for all shaders are the same 
to enable easy porting between platforms.

  return FxaaPixelShader(...);

(4.)
Insure pass prior to FXAA outputs RGBL (see next section).
Or use,

  #define FXAA_GREEN_AS_LUMA 1

(5.)
Setup engine to provide the following constants
which are used in the FxaaPixelShader() inputs,

  FxaaFloat2 fxaaQualityRcpFrame,
  FxaaFloat4 fxaaConsoleRcpFrameOpt,
  FxaaFloat4 fxaaConsoleRcpFrameOpt2,
  FxaaFloat4 fxaaConsole360RcpFrameOpt2,
  FxaaFloat fxaaQualitySubpix,
  FxaaFloat fxaaQualityEdgeThreshold,
  FxaaFloat fxaaQualityEdgeThresholdMin,
  FxaaFloat fxaaConsoleEdgeSharpness,
  FxaaFloat fxaaConsoleEdgeThreshold,
  FxaaFloat fxaaConsoleEdgeThresholdMin,
  FxaaFloat4 fxaaConsole360ConstDir

Look at the FXAA Quality FxaaPixelShader() for docs on inputs.

(6.)
Have FXAA vertex shader run as a full screen triangle,
and output "pos" and "fxaaConsolePosPos" 
such that inputs in the pixel shader provide,

  // {xy} = center of pixel
  FxaaFloat2 pos,

  // {xy__} = upper left of pixel
  // {__zw} = lower right of pixel
  FxaaFloat4 fxaaConsolePosPos,

(7.)
Insure the texture sampler(s) used by FXAA are set to bilinear filtering.


------------------------------------------------------------------------------
                    INTEGRATION - RGBL AND COLORSPACE
------------------------------------------------------------------------------
FXAA3 requires RGBL as input unless the following is set, 

  #define FXAA_GREEN_AS_LUMA 1

In which case the engine uses green in place of luma,
and requires RGB input is in a non-linear colorspace.

RGB should be LDR (low dynamic range).
Specifically do FXAA after tonemapping.

RGB data as returned by a texture fetch can be non-linear,
or linear when FXAA_GREEN_AS_LUMA is not set.
Note an "sRGB format" texture counts as linear,
because the result of a texture fetch is linear data.
Regular "RGBA8" textures in the sRGB colorspace are non-linear.

If FXAA_GREEN_AS_LUMA is not set,
luma must be stored in the alpha channel prior to running FXAA.
This luma should be in a perceptual space (could be gamma 2.0).
Example pass before FXAA where output is gamma 2.0 encoded,

  color.rgb = ToneMap(color.rgb); // linear color output
  color.rgb = sqrt(color.rgb);    // gamma 2.0 color output
  return color;

To use FXAA,

  color.rgb = ToneMap(color.rgb);  // linear color output
  color.rgb = sqrt(color.rgb);     // gamma 2.0 color output
  color.a = dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114)); // compute luma
  return color;

Another example where output is linear encoded,
say for instance writing to an sRGB formated render target,
where the render target does the conversion back to sRGB after blending,

  color.rgb = ToneMap(color.rgb); // linear color output
  return color;

To use FXAA,

  color.rgb = ToneMap(color.rgb); // linear color output
  color.a = sqrt(dot(color.rgb, FxaaFloat3(0.299, 0.587, 0.114))); // compute luma
  return color;

Getting luma correct is required for the algorithm to work correctly.


------------------------------------------------------------------------------
                          BEING LINEARLY CORRECT?
------------------------------------------------------------------------------
Applying FXAA to a framebuffer with linear RGB color will look worse.
This is very counter intuitive, but happends to be true in this case.
The reason is because dithering artifacts will be more visiable 
in a linear colorspace.


------------------------------------------------------------------------------
                             COMPLEX INTEGRATION
------------------------------------------------------------------------------
Q. What if the engine is blending into RGB before wanting to run FXAA?

A. In the last opaque pass prior to FXAA,
   have the pass write out luma into alpha.
   Then blend into RGB only.
   FXAA should be able to run ok
   assuming the blending pass did not any add aliasing.
   This should be the common case for particles and common blending passes.

A. Or use FXAA_GREEN_AS_LUMA.

============================================================================*/

/*============================================================================

                             INTEGRATION KNOBS

============================================================================*/
//
// FXAA_PS3 and FXAA_360 choose the console algorithm (FXAA3 CONSOLE).
// FXAA_360_OPT is a prototype for the new optimized 360 version.
//
// 1 = Use API.
// 0 = Don't use API.
//
/*--------------------------------------------------------------------------*/
#ifndef FXAA_PS3
    #define FXAA_PS3 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_360
    #define FXAA_360 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_360_OPT
    #define FXAA_360_OPT 0
#endif
/*==========================================================================*/
#ifndef FXAA_PC
    //
    // FXAA Quality
    // The high quality PC algorithm.
    //
    #define FXAA_PC 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_PC_CONSOLE
    //
    // The console algorithm for PC is included
    // for developers targeting really low spec machines.
    // Likely better to just run FXAA_PC, and use a really low preset.
    //
    #define FXAA_PC_CONSOLE 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_GLSL_120
    #define FXAA_GLSL_120 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_GLSL_130
    #define FXAA_GLSL_130 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_HLSL_3
    #define FXAA_HLSL_3 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_HLSL_4
    #define FXAA_HLSL_4 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_HLSL_5
    #define FXAA_HLSL_5 0
#endif
/*==========================================================================*/
#ifndef FXAA_GREEN_AS_LUMA
    //
    // For those using non-linear color,
    // and either not able to get luma in alpha, or not wanting to,
    // this enables FXAA to run using green as a proxy for luma.
    // So with this enabled, no need to pack luma in alpha.
    //
    // This will turn off AA on anything which lacks some amount of green.
    // Pure red and blue or combination of only R and B, will get no AA.
    //
    // Might want to lower the settings for both,
    //    fxaaConsoleEdgeThresholdMin
    //    fxaaQualityEdgeThresholdMin
    // In order to insure AA does not get turned off on colors 
    // which contain a minor amount of green.
    //
    // 1 = On.
    // 0 = Off.
    //
    #define FXAA_GREEN_AS_LUMA 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_EARLY_EXIT
    //
    // Controls algorithm's early exit path.
    // On PS3 turning this ON adds 2 cycles to the shader.
    // On 360 turning this OFF adds 10ths of a millisecond to the shader.
    // Turning this off on console will result in a more blurry image.
    // So this defaults to on.
    //
    // 1 = On.
    // 0 = Off.
    //
    #define FXAA_EARLY_EXIT 1
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_DISCARD
    //
    // Only valid for PC OpenGL currently.
    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.
    //
    // 1 = Use discard on pixels which don't need AA.
    //     For APIs which enable concurrent TEX+ROP from same surface.
    // 0 = Return unchanged color on pixels which don't need AA.
    //
    #define FXAA_DISCARD 0
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_FAST_PIXEL_OFFSET
    //
    // Used for GLSL 120 only.
    //
    // 1 = GL API supports fast pixel offsets
    // 0 = do not use fast pixel offsets
    //
    #ifdef GL_EXT_gpu_shader4
        #define FXAA_FAST_PIXEL_OFFSET 1
    #endif
    #ifdef GL_NV_gpu_shader5
        #define FXAA_FAST_PIXEL_OFFSET 1
    #endif
    #ifdef GL_ARB_gpu_shader5
        #define FXAA_FAST_PIXEL_OFFSET 1
    #endif
    #ifndef FXAA_FAST_PIXEL_OFFSET
        #define FXAA_FAST_PIXEL_OFFSET 0
    #endif
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_GATHER4_ALPHA
    //
    // 1 = API supports gather4 on alpha channel.
    // 0 = API does not support gather4 on alpha channel.
    //
    #if (FXAA_HLSL_5 == 1)
        #define FXAA_GATHER4_ALPHA 1
    #endif
    #ifdef GL_ARB_gpu_shader5
        #define FXAA_GATHER4_ALPHA 1
    #endif
    #ifdef GL_NV_gpu_shader5
        #define FXAA_GATHER4_ALPHA 1
    #endif
    #ifndef FXAA_GATHER4_ALPHA
        #define FXAA_GATHER4_ALPHA 0
    #endif
#endif

/*============================================================================
                      FXAA CONSOLE PS3 - TUNING KNOBS
============================================================================*/
#ifndef FXAA_CONSOLE__PS3_EDGE_SHARPNESS
    //
    // Consoles the sharpness of edges on PS3 only.
    // Non-PS3 tuning is done with shader input.
    //
    // Due to the PS3 being ALU bound,
    // there are only two safe values here: 4 and 8.
    // These options use the shaders ability to a free *|/ by 2|4|8.
    //
    // 8.0 is sharper
    // 4.0 is softer
    // 2.0 is really soft (good for vector graphics inputs)
    //
    #if 1
        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 8.0
    #endif
    #if 0
        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 4.0
    #endif
    #if 0
        #define FXAA_CONSOLE__PS3_EDGE_SHARPNESS 2.0
    #endif
#endif
/*--------------------------------------------------------------------------*/
#ifndef FXAA_CONSOLE__PS3_EDGE_THRESHOLD
    //
    // Only effects PS3.
    // Non-PS3 tuning is done with shader input.
    //
    // The minimum amount of local contrast required to apply algorithm.
    // The console setting has a different mapping than the quality setting.
    //
    // This only applies when FXAA_EARLY_EXIT is 1.
    //
    // Due to the PS3 being ALU bound,
    // there are only two safe values here: 0.25 and 0.125.
    // These options use the shaders ability to a free *|/ by 2|4|8.
    //
    // 0.125 leaves less aliasing, but is softer
    // 0.25 leaves more aliasing, and is sharper
    //
    #if 1
        #define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.125
    #else
        #define FXAA_CONSOLE__PS3_EDGE_THRESHOLD 0.25
    #endif
#endif

/*============================================================================
                        FXAA QUALITY - TUNING KNOBS
------------------------------------------------------------------------------
NOTE the other tuning knobs are now in the shader function inputs!
============================================================================*/
#ifndef FXAA_QUALITY__PRESET
    //
    // Choose the quality preset.
    // This needs to be compiled into the shader as it effects code.
    // Best option to include multiple presets is to 
    // in each shader define the preset, then include this file.
    // 
    // OPTIONS
    // -----------------------------------------------------------------------
    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)
    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
    // 39       - no dither, very expensive 
    //
    // NOTES
    // -----------------------------------------------------------------------
    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
    // 13 = about same speed as FXAA 3.9 and better than 12
    // 23 = closest to FXAA 3.9 visually and performance wise
    //  _ = the lowest digit is directly related to performance
    // _  = the highest digit is directly related to style
    // 
    #define FXAA_QUALITY__PRESET 12
#endif


/*============================================================================

                           FXAA QUALITY - PRESETS

============================================================================*/

/*============================================================================
                     FXAA QUALITY - MEDIUM DITHER PRESETS
============================================================================*/
#if (FXAA_QUALITY__PRESET == 10)
    #define FXAA_QUALITY__PS 3
    #define FXAA_QUALITY__P0 1.5
    #define FXAA_QUALITY__P1 3.0
    #define FXAA_QUALITY__P2 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 11)
    #define FXAA_QUALITY__PS 4
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 3.0
    #define FXAA_QUALITY__P3 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 12)
    #define FXAA_QUALITY__PS 5
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 4.0
    #define FXAA_QUALITY__P4 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 13)
    #define FXAA_QUALITY__PS 6
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 4.0
    #define FXAA_QUALITY__P5 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 14)
    #define FXAA_QUALITY__PS 7
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 4.0
    #define FXAA_QUALITY__P6 12.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 15)
    #define FXAA_QUALITY__PS 8
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 2.0
    #define FXAA_QUALITY__P6 4.0
    #define FXAA_QUALITY__P7 12.0
#endif

/*============================================================================
                     FXAA QUALITY - LOW DITHER PRESETS
============================================================================*/
#if (FXAA_QUALITY__PRESET == 20)
    #define FXAA_QUALITY__PS 3
    #define FXAA_QUALITY__P0 1.5
    #define FXAA_QUALITY__P1 2.0
    #define FXAA_QUALITY__P2 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 21)
    #define FXAA_QUALITY__PS 4
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 22)
    #define FXAA_QUALITY__PS 5
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 23)
    #define FXAA_QUALITY__PS 6
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 24)
    #define FXAA_QUALITY__PS 7
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 3.0
    #define FXAA_QUALITY__P6 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 25)
    #define FXAA_QUALITY__PS 8
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 2.0
    #define FXAA_QUALITY__P6 4.0
    #define FXAA_QUALITY__P7 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 26)
    #define FXAA_QUALITY__PS 9
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 2.0
    #define FXAA_QUALITY__P6 2.0
    #define FXAA_QUALITY__P7 4.0
    #define FXAA_QUALITY__P8 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 27)
    #define FXAA_QUALITY__PS 10
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 2.0
    #define FXAA_QUALITY__P6 2.0
    #define FXAA_QUALITY__P7 2.0
    #define FXAA_QUALITY__P8 4.0
    #define FXAA_QUALITY__P9 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 28)
    #define FXAA_QUALITY__PS 11
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 2.0
    #define FXAA_QUALITY__P6 2.0
    #define FXAA_QUALITY__P7 2.0
    #define FXAA_QUALITY__P8 2.0
    #define FXAA_QUALITY__P9 4.0
    #define FXAA_QUALITY__P10 8.0
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_QUALITY__PRESET == 29)
    #define FXAA_QUALITY__PS 12
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.5
    #define FXAA_QUALITY__P2 2.0
    #define FXAA_QUALITY__P3 2.0
    #define FXAA_QUALITY__P4 2.0
    #define FXAA_QUALITY__P5 2.0
    #define FXAA_QUALITY__P6 2.0
    #define FXAA_QUALITY__P7 2.0
    #define FXAA_QUALITY__P8 2.0
    #define FXAA_QUALITY__P9 2.0
    #define FXAA_QUALITY__P10 4.0
    #define FXAA_QUALITY__P11 8.0
#endif

/*============================================================================
                     FXAA QUALITY - EXTREME QUALITY
============================================================================*/
#if (FXAA_QUALITY__PRESET == 39)
    #define FXAA_QUALITY__PS 12
    #define FXAA_QUALITY__P0 1.0
    #define FXAA_QUALITY__P1 1.0
    #define FXAA_QUALITY__P2 1.0
    #define FXAA_QUALITY__P3 1.0
    #define FXAA_QUALITY__P4 1.0
    #define FXAA_QUALITY__P5 1.5
    #define FXAA_QUALITY__P6 2.0
    #define FXAA_QUALITY__P7 2.0
    #define FXAA_QUALITY__P8 2.0
    #define FXAA_QUALITY__P9 2.0
    #define FXAA_QUALITY__P10 4.0
    #define FXAA_QUALITY__P11 8.0
#endif



/*============================================================================

                                API PORTING

============================================================================*/
#if (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
    #define FxaaBool bool
    #define FxaaDiscard discard
    #define FxaaFloat float
    #define FxaaFloat2 vec2
    #define FxaaFloat3 vec3
    #define FxaaFloat4 vec4
    #define FxaaHalf float
    #define FxaaHalf2 vec2
    #define FxaaHalf3 vec3
    #define FxaaHalf4 vec4
    #define FxaaInt2 ivec2
    #define FxaaSat(x) clamp(x, 0.0, 1.0)
    #define FxaaTex sampler2D
#else
    #define FxaaBool bool
    #define FxaaDiscard clip(-1)
    #define FxaaFloat float
    #define FxaaFloat2 float2
    #define FxaaFloat3 float3
    #define FxaaFloat4 float4
    #define FxaaHalf half
    #define FxaaHalf2 half2
    #define FxaaHalf3 half3
    #define FxaaHalf4 half4
    #define FxaaSat(x) saturate(x)
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_120 == 1)
    // Requires,
    //  #version 120
    // And at least,
    //  #extension GL_EXT_gpu_shader4 : enable
    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)
    #if (FXAA_FAST_PIXEL_OFFSET == 1)
        #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
    #else
        #define FxaaTexOff(t, p, o, r) textureLod(t, p + (o * r), 0.0)
    #endif
    #if (FXAA_GATHER4_ALPHA == 1)
        // use #extension GL_ARB_gpu_shader5 : enable
        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)
        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
    #endif
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_GLSL_130 == 1)
    // Requires "#version 130" or better
    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)
    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
    #if (FXAA_GATHER4_ALPHA == 1)
        // use #extension GL_ARB_gpu_shader5 : enable
        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)
        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
    #endif
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_HLSL_3 == 1) || (FXAA_360 == 1) || (FXAA_PS3 == 1)
    #define FxaaInt2 float2
    #define FxaaTex sampler2D
    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))
    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_HLSL_4 == 1)
    #define FxaaInt2 int2
    struct FxaaTex { SamplerState smpl; Texture2D tex; };
    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
#endif
/*--------------------------------------------------------------------------*/
#if (FXAA_HLSL_5 == 1)
    #define FxaaInt2 int2
    struct FxaaTex { SamplerState smpl; Texture2D tex; };
    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)
    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)
    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)
    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)
#endif


/*============================================================================
                   GREEN AS LUMA OPTION SUPPORT FUNCTION
============================================================================*/
#if (FXAA_GREEN_AS_LUMA == 0)
    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
#else
    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
#endif    




/*============================================================================

                             FXAA3 QUALITY - PC

============================================================================*/
#if (FXAA_PC == 1)
/*--------------------------------------------------------------------------*/
FxaaFloat4 FxaaPixelShader(
    //
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = center of pixel
    FxaaFloat2 pos,
    //
    // Used only for FXAA Console, and not used on the 360 version.
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy__} = upper left of pixel
    // {__zw} = lower right of pixel
    FxaaFloat4 fxaaConsolePosPos,
    //
    // Input color texture.
    // {rgb_} = color in linear or perceptual color space
    // if (FXAA_GREEN_AS_LUMA == 0)
    //     {___a} = luma in perceptual color space (not linear)
    FxaaTex tex,
    //
    // Only used on the optimized 360 version of FXAA Console.
    // For everything but 360, just use the same input here as for "tex".
    // For 360, same texture, just alias with a 2nd sampler.
    // This sampler needs to have an exponent bias of -1.
    FxaaTex fxaaConsole360TexExpBiasNegOne,
    //
    // Only used on the optimized 360 version of FXAA Console.
    // For everything but 360, just use the same input here as for "tex".
    // For 360, same texture, just alias with a 3nd sampler.
    // This sampler needs to have an exponent bias of -2.
    FxaaTex fxaaConsole360TexExpBiasNegTwo,
    //
    // Only used on FXAA Quality.
    // This must be from a constant/uniform.
    // {x_} = 1.0/screenWidthInPixels
    // {_y} = 1.0/screenHeightInPixels
    FxaaFloat2 fxaaQualityRcpFrame,
    //
    // Only used on FXAA Console.
    // This must be from a constant/uniform.
    // This effects sub-pixel AA quality and inversely sharpness.
    //   Where N ranges between,
    //     N = 0.50 (default)
    //     N = 0.33 (sharper)
    // {x___} = -N/screenWidthInPixels  
    // {_y__} = -N/screenHeightInPixels
    // {__z_} =  N/screenWidthInPixels  
    // {___w} =  N/screenHeightInPixels 
    FxaaFloat4 fxaaConsoleRcpFrameOpt,
    //
    // Only used on FXAA Console.
    // Not used on 360, but used on PS3 and PC.
    // This must be from a constant/uniform.
    // {x___} = -2.0/screenWidthInPixels  
    // {_y__} = -2.0/screenHeightInPixels
    // {__z_} =  2.0/screenWidthInPixels  
    // {___w} =  2.0/screenHeightInPixels 
    FxaaFloat4 fxaaConsoleRcpFrameOpt2,
    //
    // Only used on FXAA Console.
    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
    // This must be from a constant/uniform.
    // {x___} =  8.0/screenWidthInPixels  
    // {_y__} =  8.0/screenHeightInPixels
    // {__z_} = -4.0/screenWidthInPixels  
    // {___w} = -4.0/screenHeightInPixels 
    FxaaFloat4 fxaaConsole360RcpFrameOpt2,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY__SUBPIX define.
    // It is here now to allow easier tuning.
    // Choose the amount of sub-pixel aliasing removal.
    // This can effect sharpness.
    //   1.00 - upper limit (softer)
    //   0.75 - default amount of filtering
    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
    //   0.25 - almost off
    //   0.00 - completely off
    FxaaFloat fxaaQualitySubpix,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY__EDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // The minimum amount of local contrast required to apply algorithm.
    //   0.333 - too little (faster)
    //   0.250 - low quality
    //   0.166 - default
    //   0.125 - high quality 
    //   0.063 - overkill (slower)
    FxaaFloat fxaaQualityEdgeThreshold,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY__EDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    //   0.0833 - upper limit (default, the start of visible unfiltered edges)
    //   0.0625 - high quality (faster)
    //   0.0312 - visible limit (slower)
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaQualityEdgeThresholdMin,
    // 
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLE__EDGE_SHARPNESS define.
    // It is here now to allow easier tuning.
    // This does not effect PS3, as this needs to be compiled in.
    //   Use FXAA_CONSOLE__PS3_EDGE_SHARPNESS for PS3.
    //   Due to the PS3 being ALU bound,
    //   there are only three safe values here: 2 and 4 and 8.
    //   These options use the shaders ability to a free *|/ by 2|4|8.
    // For all other platforms can be a non-power of two.
    //   8.0 is sharper (default!!!)
    //   4.0 is softer
    //   2.0 is really soft (good only for vector graphics inputs)
    FxaaFloat fxaaConsoleEdgeSharpness,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLE__EDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // This does not effect PS3, as this needs to be compiled in.
    //   Use FXAA_CONSOLE__PS3_EDGE_THRESHOLD for PS3.
    //   Due to the PS3 being ALU bound,
    //   there are only two safe values here: 1/4 and 1/8.
    //   These options use the shaders ability to a free *|/ by 2|4|8.
    // The console setting has a different mapping than the quality setting.
    // Other platforms can use other values.
    //   0.125 leaves less aliasing, but is softer (default!!!)
    //   0.25 leaves more aliasing, and is sharper
    FxaaFloat fxaaConsoleEdgeThreshold,
    //
    // Only used on FXAA Console.
    // This used to be the FXAA_CONSOLE__EDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    // The console setting has a different mapping than the quality setting.
    // This only applies when FXAA_EARLY_EXIT is 1.
    // This does not apply to PS3, 
    // PS3 was simplified to avoid more shader instructions.
    //   0.06 - faster but more aliasing in darks
    //   0.05 - default
    //   0.04 - slower and less aliasing in darks
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaConsoleEdgeThresholdMin,
    //    
    // Extra constants for 360 FXAA Console only.
    // Use zeros or anything else for other platforms.
    // These must be in physical constant registers and NOT immedates.
    // Immedates will result in compiler un-optimizing.
    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
    FxaaFloat4 fxaaConsole360ConstDir
) {
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posM;
    posM.x = pos.x;
    posM.y = pos.y;
    #if (FXAA_GATHER4_ALPHA == 1)
        #if (FXAA_DISCARD == 0)
            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
            #if (FXAA_GREEN_AS_LUMA == 0)
                #define lumaM rgbyM.w
            #else
                #define lumaM rgbyM.y
            #endif
        #endif
        #if (FXAA_GREEN_AS_LUMA == 0)
            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
        #else
            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
        #endif
        #if (FXAA_DISCARD == 1)
            #define lumaM luma4A.w
        #endif
        #define lumaE luma4A.z
        #define lumaS luma4A.x
        #define lumaSE luma4A.y
        #define lumaNW luma4B.w
        #define lumaN luma4B.z
        #define lumaW luma4B.x
    #else
        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
        #if (FXAA_GREEN_AS_LUMA == 0)
            #define lumaM rgbyM.w
        #else
            #define lumaM rgbyM.y
        #endif
        FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
        FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
        FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
        FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
    #endif
/*--------------------------------------------------------------------------*/
    FxaaFloat maxSM = max(lumaS, lumaM);
    FxaaFloat minSM = min(lumaS, lumaM);
    FxaaFloat maxESM = max(lumaE, maxSM);
    FxaaFloat minESM = min(lumaE, minSM);
    FxaaFloat maxWN = max(lumaN, lumaW);
    FxaaFloat minWN = min(lumaN, lumaW);
    FxaaFloat rangeMax = max(maxWN, maxESM);
    FxaaFloat rangeMin = min(minWN, minESM);
    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
    FxaaFloat range = rangeMax - rangeMin;
    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
    FxaaBool earlyExit = range < rangeMaxClamped;
/*--------------------------------------------------------------------------*/
    if(earlyExit)
        #if (FXAA_DISCARD == 1)
            FxaaDiscard;
        #else
            return rgbyM;
        #endif
/*--------------------------------------------------------------------------*/
    #if (FXAA_GATHER4_ALPHA == 0)
        FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
        FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
    #else
        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
    #endif
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNS = lumaN + lumaS;
    FxaaFloat lumaWE = lumaW + lumaE;
    FxaaFloat subpixRcpRange = 1.0/range;
    FxaaFloat subpixNSWE = lumaNS + lumaWE;
    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNESE = lumaNE + lumaSE;
    FxaaFloat lumaNWNE = lumaNW + lumaNE;
    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNWSW = lumaNW + lumaSW;
    FxaaFloat lumaSWSE = lumaSW + lumaSE;
    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
/*--------------------------------------------------------------------------*/
    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
    FxaaBool horzSpan = edgeHorz >= edgeVert;
    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
/*--------------------------------------------------------------------------*/
    if(!horzSpan) lumaN = lumaW;
    if(!horzSpan) lumaS = lumaE;
    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
/*--------------------------------------------------------------------------*/
    FxaaFloat gradientN = lumaN - lumaM;
    FxaaFloat gradientS = lumaS - lumaM;
    FxaaFloat lumaNN = lumaN + lumaM;
    FxaaFloat lumaSS = lumaS + lumaM;
    FxaaBool pairN = abs(gradientN) >= abs(gradientS);
    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
    if(pairN) lengthSign = -lengthSign;
    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posB;
    posB.x = posM.x;
    posB.y = posM.y;
    FxaaFloat2 offNP;
    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
    if(!horzSpan) posB.x += lengthSign * 0.5;
    if( horzSpan) posB.y += lengthSign * 0.5;
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posN;
    posN.x = posB.x - offNP.x * FXAA_QUALITY__P0;
    posN.y = posB.y - offNP.y * FXAA_QUALITY__P0;
    FxaaFloat2 posP;
    posP.x = posB.x + offNP.x * FXAA_QUALITY__P0;
    posP.y = posB.y + offNP.y * FXAA_QUALITY__P0;
    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
    FxaaFloat subpixE = subpixC * subpixC;
    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
/*--------------------------------------------------------------------------*/
    if(!pairN) lumaNN = lumaSS;
    FxaaFloat gradientScaled = gradient * 1.0/4.0;
    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
    FxaaFloat subpixF = subpixD * subpixE;
    FxaaBool lumaMLTZero = lumaMM < 0.0;
/*--------------------------------------------------------------------------*/
    lumaEndN -= lumaNN * 0.5;
    lumaEndP -= lumaNN * 0.5;
    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P1;
    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P1;
    FxaaBool doneNP = (!doneN) || (!doneP);
    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P1;
    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P1;
/*--------------------------------------------------------------------------*/
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P2;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P2;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P2;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P2;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY__PS > 3)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P3;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P3;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P3;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P3;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY__PS > 4)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P4;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P4;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P4;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P4;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY__PS > 5)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P5;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P5;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P5;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P5;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY__PS > 6)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P6;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P6;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P6;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P6;
/*--------------------------------------------------------------------------*/
                        #if (FXAA_QUALITY__PS > 7)
                        if(doneNP) {
                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P7;
                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P7;
                            doneNP = (!doneN) || (!doneP);
                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P7;
                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P7;
/*--------------------------------------------------------------------------*/
    #if (FXAA_QUALITY__PS > 8)
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P8;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P8;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P8;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P8;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY__PS > 9)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P9;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P9;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P9;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P9;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY__PS > 10)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P10;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P10;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P10;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P10;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY__PS > 11)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P11;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P11;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P11;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P11;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY__PS > 12)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY__P12;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY__P12;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY__P12;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY__P12;
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
    #endif
/*--------------------------------------------------------------------------*/
                        }
                        #endif
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
/*--------------------------------------------------------------------------*/
    FxaaFloat dstN = posM.x - posN.x;
    FxaaFloat dstP = posP.x - posM.x;
    if(!horzSpan) dstN = posM.y - posN.y;
    if(!horzSpan) dstP = posP.y - posM.y;
/*--------------------------------------------------------------------------*/
    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
    FxaaFloat spanLength = (dstP + dstN);
    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
    FxaaFloat spanLengthRcp = 1.0/spanLength;
/*--------------------------------------------------------------------------*/
    FxaaBool directionN = dstN < dstP;
    FxaaFloat dst = min(dstN, dstP);
    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
    FxaaFloat subpixG = subpixF * subpixF;
    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
/*--------------------------------------------------------------------------*/
    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
    #if (FXAA_DISCARD == 1)
        return FxaaTexTop(tex, posM);
    #else
        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
    #endif
}
/*==========================================================================*/
#endif




/*============================================================================

                         FXAA3 CONSOLE - PC VERSION
                         
------------------------------------------------------------------------------
Instead of using this on PC, I'd suggest just using FXAA Quality with
    #define FXAA_QUALITY__PRESET 10
Or 
    #define FXAA_QUALITY__PRESET 20
Either are higher qualilty and almost as fast as this on modern PC GPUs.
============================================================================*/
#if (FXAA_PC_CONSOLE == 1)
/*--------------------------------------------------------------------------*/
FxaaFloat4 FxaaPixelShader(
    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!
    FxaaFloat2 pos,
    FxaaFloat4 fxaaConsolePosPos,
    FxaaTex tex,
    FxaaTex fxaaConsole360TexExpBiasNegOne,
    FxaaTex fxaaConsole360TexExpBiasNegTwo,
    FxaaFloat2 fxaaQualityRcpFrame,
    FxaaFloat4 fxaaConsoleRcpFrameOpt,
    FxaaFloat4 fxaaConsoleRcpFrameOpt2,
    FxaaFloat4 fxaaConsole360RcpFrameOpt2,
    FxaaFloat fxaaQualitySubpix,
    FxaaFloat fxaaQualityEdgeThreshold,
    FxaaFloat fxaaQualityEdgeThresholdMin,
    FxaaFloat fxaaConsoleEdgeSharpness,
    FxaaFloat fxaaConsoleEdgeThreshold,
    FxaaFloat fxaaConsoleEdgeThresholdMin,
    FxaaFloat4 fxaaConsole360ConstDir
) {
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNw = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.xy));
    FxaaFloat lumaSw = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.xw));
    FxaaFloat lumaNe = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.zy));
    FxaaFloat lumaSe = FxaaLuma(FxaaTexTop(tex, fxaaConsolePosPos.zw));
/*--------------------------------------------------------------------------*/
    FxaaFloat4 rgbyM = FxaaTexTop(tex, pos.xy);
    #if (FXAA_GREEN_AS_LUMA == 0)
        FxaaFloat lumaM = rgbyM.w;
    #else
        FxaaFloat lumaM = rgbyM.y;
    #endif
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaMaxNwSw = max(lumaNw, lumaSw);
    lumaNe += 1.0/384.0;
    FxaaFloat lumaMinNwSw = min(lumaNw, lumaSw);
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaMaxNeSe = max(lumaNe, lumaSe);
    FxaaFloat lumaMinNeSe = min(lumaNe, lumaSe);
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaMax = max(lumaMaxNeSe, lumaMaxNwSw);
    FxaaFloat lumaMin = min(lumaMinNeSe, lumaMinNwSw);
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaMaxScaled = lumaMax * fxaaConsoleEdgeThreshold;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaMinM = min(lumaMin, lumaM);
    FxaaFloat lumaMaxScaledClamped = max(fxaaConsoleEdgeThresholdMin, lumaMaxScaled);
    FxaaFloat lumaMaxM = max(lumaMax, lumaM);
    FxaaFloat dirSwMinusNe = lumaSw - lumaNe;
    FxaaFloat lumaMaxSubMinM = lumaMaxM - lumaMinM;
    FxaaFloat dirSeMinusNw = lumaSe - lumaNw;
    if(lumaMaxSubMinM < lumaMaxScaledClamped) return rgbyM;
/*--------------------------------------------------------------------------*/
    FxaaFloat2 dir;
    dir.x = dirSwMinusNe + dirSeMinusNw;
    dir.y = dirSwMinusNe - dirSeMinusNw;
/*--------------------------------------------------------------------------*/
    FxaaFloat2 dir1 = normalize(dir.xy);
    FxaaFloat4 rgbyN1 = FxaaTexTop(tex, pos.xy - dir1 * fxaaConsoleRcpFrameOpt.zw);
    FxaaFloat4 rgbyP1 = FxaaTexTop(tex, pos.xy + dir1 * fxaaConsoleRcpFrameOpt.zw);
/*--------------------------------------------------------------------------*/
    FxaaFloat dirAbsMinTimesC = min(abs(dir1.x), abs(dir1.y)) * fxaaConsoleEdgeSharpness;
    FxaaFloat2 dir2 = clamp(dir1.xy / dirAbsMinTimesC, -2.0, 2.0);
/*--------------------------------------------------------------------------*/
    FxaaFloat4 rgbyN2 = FxaaTexTop(tex, pos.xy - dir2 * fxaaConsoleRcpFrameOpt2.zw);
    FxaaFloat4 rgbyP2 = FxaaTexTop(tex, pos.xy + dir2 * fxaaConsoleRcpFrameOpt2.zw);
/*--------------------------------------------------------------------------*/
    FxaaFloat4 rgbyA = rgbyN1 + rgbyP1;
    FxaaFloat4 rgbyB = ((rgbyN2 + rgbyP2) * 0.25) + (rgbyA * 0.25);
/*--------------------------------------------------------------------------*/
    #if (FXAA_GREEN_AS_LUMA == 0)
        FxaaBool twoTap = (rgbyB.w < lumaMin) || (rgbyB.w > lumaMax);
    #else
        FxaaBool twoTap = (rgbyB.y < lumaMin) || (rgbyB.y > lumaMax);
    #endif
    if(twoTap) rgbyB.xyz = rgbyA.xyz * 0.5;
    return rgbyB; }
/*==========================================================================*/
#endif



/*============================================================================

                      FXAA3 CONSOLE - 360 PIXEL SHADER 

------------------------------------------------------------------------------
This optimized version thanks to suggestions from Andy Luedke.
Should be fully tex bound in all cases.
As of the FXAA 3.11 release, I have still not tested this code,
however I fixed a bug which was in both FXAA 3.9 and FXAA 3.10.
And note this is replacing the old unoptimized version.
If it does not work, please let me know so I can fix it.
============================================================================*/
#if (FXAA_360 == 1)
/*--------------------------------------------------------------------------*/
[reduceTempRegUsage(4)]
float4 FxaaPixelShader(
    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!
    FxaaFloat2 pos,
    FxaaFloat4 fxaaConsolePosPos,
    FxaaTex tex,
    FxaaTex fxaaConsole360TexExpBiasNegOne,
    FxaaTex fxaaConsole360TexExpBiasNegTwo,
    FxaaFloat2 fxaaQualityRcpFrame,
    FxaaFloat4 fxaaConsoleRcpFrameOpt,
    FxaaFloat4 fxaaConsoleRcpFrameOpt2,
    FxaaFloat4 fxaaConsole360RcpFrameOpt2,
    FxaaFloat fxaaQualitySubpix,
    FxaaFloat fxaaQualityEdgeThreshold,
    FxaaFloat fxaaQualityEdgeThresholdMin,
    FxaaFloat fxaaConsoleEdgeSharpness,
    FxaaFloat fxaaConsoleEdgeThreshold,
    FxaaFloat fxaaConsoleEdgeThresholdMin,
    FxaaFloat4 fxaaConsole360ConstDir
) {
/*--------------------------------------------------------------------------*/
    float4 lumaNwNeSwSe;
    #if (FXAA_GREEN_AS_LUMA == 0)
        asm { 
            tfetch2D lumaNwNeSwSe.w___, tex, pos.xy, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD=false
            tfetch2D lumaNwNeSwSe._w__, tex, pos.xy, OffsetX =  0.5, OffsetY = -0.5, UseComputedLOD=false
            tfetch2D lumaNwNeSwSe.__w_, tex, pos.xy, OffsetX = -0.5, OffsetY =  0.5, UseComputedLOD=false
            tfetch2D lumaNwNeSwSe.___w, tex, pos.xy, OffsetX =  0.5, OffsetY =  0.5, UseComputedLOD=false
        };
    #else
        asm { 
            tfetch2D lumaNwNeSwSe.y___, tex, pos.xy, OffsetX = -0.5, OffsetY = -0.5, UseComputedLOD=false
            tfetch2D lumaNwNeSwSe._y__, tex, pos.xy, OffsetX =  0.5, OffsetY = -0.5, UseComputedLOD=false
            tfetch2D lumaNwNeSwSe.__y_, tex, pos.xy, OffsetX = -0.5, OffsetY =  0.5, UseComputedLOD=false
            tfetch2D lumaNwNeSwSe.___y, tex, pos.xy, OffsetX =  0.5, OffsetY =  0.5, UseComputedLOD=false
        };
    #endif
/*--------------------------------------------------------------------------*/
    lumaNwNeSwSe.y += 1.0/384.0;
    float2 lumaMinTemp = min(lumaNwNeSwSe.xy, lumaNwNeSwSe.zw);
    float2 lumaMaxTemp = max(lumaNwNeSwSe.xy, lumaNwNeSwSe.zw);
    float lumaMin = min(lumaMinTemp.x, lumaMinTemp.y);
    float lumaMax = max(lumaMaxTemp.x, lumaMaxTemp.y);
/*--------------------------------------------------------------------------*/
    float4 rgbyM = tex2Dlod(tex, float4(pos.xy, 0.0, 0.0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        float lumaMinM = min(lumaMin, rgbyM.w);
        float lumaMaxM = max(lumaMax, rgbyM.w);
    #else
        float lumaMinM = min(lumaMin, rgbyM.y);
        float lumaMaxM = max(lumaMax, rgbyM.y);
    #endif        
    if((lumaMaxM - lumaMinM) < max(fxaaConsoleEdgeThresholdMin, lumaMax * fxaaConsoleEdgeThreshold)) return rgbyM;
/*--------------------------------------------------------------------------*/
    float2 dir;
    dir.x = dot(lumaNwNeSwSe, fxaaConsole360ConstDir.yyxx);
    dir.y = dot(lumaNwNeSwSe, fxaaConsole360ConstDir.xyxy);
    dir = normalize(dir);
/*--------------------------------------------------------------------------*/
    float4 dir1 = dir.xyxy * fxaaConsoleRcpFrameOpt.xyzw;
/*--------------------------------------------------------------------------*/
    float4 dir2;
    float dirAbsMinTimesC = min(abs(dir.x), abs(dir.y)) * fxaaConsoleEdgeSharpness;
    dir2 = saturate(fxaaConsole360ConstDir.zzww * dir.xyxy / dirAbsMinTimesC + 0.5);
    dir2 = dir2 * fxaaConsole360RcpFrameOpt2.xyxy + fxaaConsole360RcpFrameOpt2.zwzw;
/*--------------------------------------------------------------------------*/
    float4 rgbyN1 = tex2Dlod(fxaaConsole360TexExpBiasNegOne, float4(pos.xy + dir1.xy, 0.0, 0.0));
    float4 rgbyP1 = tex2Dlod(fxaaConsole360TexExpBiasNegOne, float4(pos.xy + dir1.zw, 0.0, 0.0));
    float4 rgbyN2 = tex2Dlod(fxaaConsole360TexExpBiasNegTwo, float4(pos.xy + dir2.xy, 0.0, 0.0));
    float4 rgbyP2 = tex2Dlod(fxaaConsole360TexExpBiasNegTwo, float4(pos.xy + dir2.zw, 0.0, 0.0));
/*--------------------------------------------------------------------------*/
    float4 rgbyA = rgbyN1 + rgbyP1;
    float4 rgbyB = rgbyN2 + rgbyP2 + rgbyA * 0.5;
/*--------------------------------------------------------------------------*/
    float4 rgbyR = ((FxaaLuma(rgbyB) - lumaMax) > 0.0) ? rgbyA : rgbyB; 
    rgbyR = ((FxaaLuma(rgbyB) - lumaMin) > 0.0) ? rgbyR : rgbyA; 
    return rgbyR; }
/*==========================================================================*/
#endif



/*============================================================================

         FXAA3 CONSOLE - OPTIMIZED PS3 PIXEL SHADER (NO EARLY EXIT)

==============================================================================
The code below does not exactly match the assembly.
I have a feeling that 12 cycles is possible, but was not able to get there.
Might have to increase register count to get full performance.
Note this shader does not use perspective interpolation.

Use the following cgc options,

  --fenable-bx2 --fastmath --fastprecision --nofloatbindings

------------------------------------------------------------------------------
                             NVSHADERPERF OUTPUT
------------------------------------------------------------------------------
For reference and to aid in debug, output of NVShaderPerf should match this,

Shader to schedule:
  0: texpkb h0.w(TRUE), v5.zyxx, #0
  2: addh h2.z(TRUE), h0.w, constant(0.001953, 0.000000, 0.000000, 0.000000).x
  4: texpkb h0.w(TRUE), v5.xwxx, #0
  6: addh h0.z(TRUE), -h2, h0.w
  7: texpkb h1.w(TRUE), v5, #0
  9: addh h0.x(TRUE), h0.z, -h1.w
 10: addh h3.w(TRUE), h0.z, h1
 11: texpkb h2.w(TRUE), v5.zwzz, #0
 13: addh h0.z(TRUE), h3.w, -h2.w
 14: addh h0.x(TRUE), h2.w, h0
 15: nrmh h1.xz(TRUE), h0_n
 16: minh_m8 h0.x(TRUE), |h1|, |h1.z|
 17: maxh h4.w(TRUE), h0, h1
 18: divx h2.xy(TRUE), h1_n.xzzw, h0_n
 19: movr r1.zw(TRUE), v4.xxxy
 20: madr r2.xz(TRUE), -h1, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zzww, r1.zzww
 22: minh h5.w(TRUE), h0, h1
 23: texpkb h0(TRUE), r2.xzxx, #0
 25: madr r0.zw(TRUE), h1.xzxz, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w), r1
 27: maxh h4.x(TRUE), h2.z, h2.w
 28: texpkb h1(TRUE), r0.zwzz, #0
 30: addh_d2 h1(TRUE), h0, h1
 31: madr r0.xy(TRUE), -h2, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz
 33: texpkb h0(TRUE), r0, #0
 35: minh h4.z(TRUE), h2, h2.w
 36: fenct TRUE
 37: madr r1.xy(TRUE), h2, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz
 39: texpkb h2(TRUE), r1, #0
 41: addh_d2 h0(TRUE), h0, h2
 42: maxh h2.w(TRUE), h4, h4.x
 43: minh h2.x(TRUE), h5.w, h4.z
 44: addh_d2 h0(TRUE), h0, h1
 45: slth h2.x(TRUE), h0.w, h2
 46: sgth h2.w(TRUE), h0, h2
 47: movh h0(TRUE), h0
 48: addx.c0 rc(TRUE), h2, h2.w
 49: movh h0(c0.NE.x), h1

IPU0 ------ Simplified schedule: --------
Pass |  Unit  |  uOp |  PC:  Op
-----+--------+------+-------------------------
   1 | SCT0/1 |  mov |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;
     |    TEX |  txl |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;
     |   SCB1 |  add |   2:  ADDh h2.z, h0.--w-, const.--x-;
     |        |      |
   2 | SCT0/1 |  mov |   4:  TXLr h0.w, g[TEX1].xwxx, const.xxxx, TEX0;
     |    TEX |  txl |   4:  TXLr h0.w, g[TEX1].xwxx, const.xxxx, TEX0;
     |   SCB1 |  add |   6:  ADDh h0.z,-h2, h0.--w-;
     |        |      |
   3 | SCT0/1 |  mov |   7:  TXLr h1.w, g[TEX1], const.xxxx, TEX0;
     |    TEX |  txl |   7:  TXLr h1.w, g[TEX1], const.xxxx, TEX0;
     |   SCB0 |  add |   9:  ADDh h0.x, h0.z---,-h1.w---;
     |   SCB1 |  add |  10:  ADDh h3.w, h0.---z, h1;
     |        |      |
   4 | SCT0/1 |  mov |  11:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;
     |    TEX |  txl |  11:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;
     |   SCB0 |  add |  14:  ADDh h0.x, h2.w---, h0;
     |   SCB1 |  add |  13:  ADDh h0.z, h3.--w-,-h2.--w-;
     |        |      |
   5 |   SCT1 |  mov |  15:  NRMh h1.xz, h0;
     |    SRB |  nrm |  15:  NRMh h1.xz, h0;
     |   SCB0 |  min |  16:  MINh*8 h0.x, |h1|, |h1.z---|;
     |   SCB1 |  max |  17:  MAXh h4.w, h0, h1;
     |        |      |
   6 |   SCT0 |  div |  18:  DIVx h2.xy, h1.xz--, h0;
     |   SCT1 |  mov |  19:  MOVr r1.zw, g[TEX0].--xy;
     |   SCB0 |  mad |  20:  MADr r2.xz,-h1, const.z-w-, r1.z-w-;
     |   SCB1 |  min |  22:  MINh h5.w, h0, h1;
     |        |      |
   7 | SCT0/1 |  mov |  23:  TXLr h0, r2.xzxx, const.xxxx, TEX0;
     |    TEX |  txl |  23:  TXLr h0, r2.xzxx, const.xxxx, TEX0;
     |   SCB0 |  max |  27:  MAXh h4.x, h2.z---, h2.w---;
     |   SCB1 |  mad |  25:  MADr r0.zw, h1.--xz, const, r1;
     |        |      |
   8 | SCT0/1 |  mov |  28:  TXLr h1, r0.zwzz, const.xxxx, TEX0;
     |    TEX |  txl |  28:  TXLr h1, r0.zwzz, const.xxxx, TEX0;
     | SCB0/1 |  add |  30:  ADDh/2 h1, h0, h1;
     |        |      |
   9 |   SCT0 |  mad |  31:  MADr r0.xy,-h2, const.xy--, r1.zw--;
     |   SCT1 |  mov |  33:  TXLr h0, r0, const.zzzz, TEX0;
     |    TEX |  txl |  33:  TXLr h0, r0, const.zzzz, TEX0;
     |   SCB1 |  min |  35:  MINh h4.z, h2, h2.--w-;
     |        |      |
  10 |   SCT0 |  mad |  37:  MADr r1.xy, h2, const.xy--, r1.zw--;
     |   SCT1 |  mov |  39:  TXLr h2, r1, const.zzzz, TEX0;
     |    TEX |  txl |  39:  TXLr h2, r1, const.zzzz, TEX0;
     | SCB0/1 |  add |  41:  ADDh/2 h0, h0, h2;
     |        |      |
  11 |   SCT0 |  min |  43:  MINh h2.x, h5.w---, h4.z---;
     |   SCT1 |  max |  42:  MAXh h2.w, h4, h4.---x;
     | SCB0/1 |  add |  44:  ADDh/2 h0, h0, h1;
     |        |      |
  12 |   SCT0 |  set |  45:  SLTh h2.x, h0.w---, h2;
     |   SCT1 |  set |  46:  SGTh h2.w, h0, h2;
     | SCB0/1 |  mul |  47:  MOVh h0, h0;
     |        |      |
  13 |   SCT0 |  mad |  48:  ADDxc0_s rc, h2, h2.w---;
     | SCB0/1 |  mul |  49:  MOVh h0(NE0.xxxx), h1;
 
Pass   SCT  TEX  SCB
  1:   0% 100%  25%
  2:   0% 100%  25%
  3:   0% 100%  50%
  4:   0% 100%  50%
  5:   0%   0%  50%
  6: 100%   0%  75%
  7:   0% 100%  75%
  8:   0% 100% 100%
  9:   0% 100%  25%
 10:   0% 100% 100%
 11:  50%   0% 100%
 12:  50%   0% 100%
 13:  25%   0% 100%

MEAN:  17%  61%  67%

Pass   SCT0  SCT1   TEX  SCB0  SCB1
  1:    0%    0%  100%    0%  100%
  2:    0%    0%  100%    0%  100%
  3:    0%    0%  100%  100%  100%
  4:    0%    0%  100%  100%  100%
  5:    0%    0%    0%  100%  100%
  6:  100%  100%    0%  100%  100%
  7:    0%    0%  100%  100%  100%
  8:    0%    0%  100%  100%  100%
  9:    0%    0%  100%    0%  100%
 10:    0%    0%  100%  100%  100%
 11:  100%  100%    0%  100%  100%
 12:  100%  100%    0%  100%  100%
 13:  100%    0%    0%  100%  100%

MEAN:   30%   23%   61%   76%  100%
Fragment Performance Setup: Driver RSX Compiler, GPU RSX, Flags 0x5
Results 13 cycles, 3 r regs, 923,076,923 pixels/s
============================================================================*/
#if (FXAA_PS3 == 1) && (FXAA_EARLY_EXIT == 0)
/*--------------------------------------------------------------------------*/
#pragma regcount 7
#pragma disablepc all
#pragma option O3
#pragma option OutColorPrec=fp16
#pragma texformat default RGBA8
/*==========================================================================*/
half4 FxaaPixelShader(
    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!
    FxaaFloat2 pos,
    FxaaFloat4 fxaaConsolePosPos,
    FxaaTex tex,
    FxaaTex fxaaConsole360TexExpBiasNegOne,
    FxaaTex fxaaConsole360TexExpBiasNegTwo,
    FxaaFloat2 fxaaQualityRcpFrame,
    FxaaFloat4 fxaaConsoleRcpFrameOpt,
    FxaaFloat4 fxaaConsoleRcpFrameOpt2,
    FxaaFloat4 fxaaConsole360RcpFrameOpt2,
    FxaaFloat fxaaQualitySubpix,
    FxaaFloat fxaaQualityEdgeThreshold,
    FxaaFloat fxaaQualityEdgeThresholdMin,
    FxaaFloat fxaaConsoleEdgeSharpness,
    FxaaFloat fxaaConsoleEdgeThreshold,
    FxaaFloat fxaaConsoleEdgeThresholdMin,
    FxaaFloat4 fxaaConsole360ConstDir
) {
/*--------------------------------------------------------------------------*/
// (1)
    half4 dir;
    half4 lumaNe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zy, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        lumaNe.w += half(1.0/512.0);
        dir.x = -lumaNe.w;
        dir.z = -lumaNe.w;
    #else
        lumaNe.y += half(1.0/512.0);
        dir.x = -lumaNe.y;
        dir.z = -lumaNe.y;
    #endif
/*--------------------------------------------------------------------------*/
// (2)
    half4 lumaSw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xw, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        dir.x += lumaSw.w;
        dir.z += lumaSw.w;
    #else
        dir.x += lumaSw.y;
        dir.z += lumaSw.y;
    #endif        
/*--------------------------------------------------------------------------*/
// (3)
    half4 lumaNw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xy, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        dir.x -= lumaNw.w;
        dir.z += lumaNw.w;
    #else
        dir.x -= lumaNw.y;
        dir.z += lumaNw.y;
    #endif
/*--------------------------------------------------------------------------*/
// (4)
    half4 lumaSe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zw, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        dir.x += lumaSe.w;
        dir.z -= lumaSe.w;
    #else
        dir.x += lumaSe.y;
        dir.z -= lumaSe.y;
    #endif
/*--------------------------------------------------------------------------*/
// (5)
    half4 dir1_pos;
    dir1_pos.xy = normalize(dir.xyz).xz;
    half dirAbsMinTimesC = min(abs(dir1_pos.x), abs(dir1_pos.y)) * half(FXAA_CONSOLE__PS3_EDGE_SHARPNESS);
/*--------------------------------------------------------------------------*/
// (6)
    half4 dir2_pos;
    dir2_pos.xy = clamp(dir1_pos.xy / dirAbsMinTimesC, half(-2.0), half(2.0));
    dir1_pos.zw = pos.xy;
    dir2_pos.zw = pos.xy;
    half4 temp1N;
    temp1N.xy = dir1_pos.zw - dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;
/*--------------------------------------------------------------------------*/
// (7)
    temp1N = h4tex2Dlod(tex, half4(temp1N.xy, 0.0, 0.0));
    half4 rgby1;
    rgby1.xy = dir1_pos.zw + dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;
/*--------------------------------------------------------------------------*/
// (8)
    rgby1 = h4tex2Dlod(tex, half4(rgby1.xy, 0.0, 0.0));
    rgby1 = (temp1N + rgby1) * 0.5;
/*--------------------------------------------------------------------------*/
// (9)
    half4 temp2N;
    temp2N.xy = dir2_pos.zw - dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;
    temp2N = h4tex2Dlod(tex, half4(temp2N.xy, 0.0, 0.0));
/*--------------------------------------------------------------------------*/
// (10)
    half4 rgby2;
    rgby2.xy = dir2_pos.zw + dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;
    rgby2 = h4tex2Dlod(tex, half4(rgby2.xy, 0.0, 0.0));
    rgby2 = (temp2N + rgby2) * 0.5;
/*--------------------------------------------------------------------------*/
// (11)
    // compilier moves these scalar ops up to other cycles
    #if (FXAA_GREEN_AS_LUMA == 0)
        half lumaMin = min(min(lumaNw.w, lumaSw.w), min(lumaNe.w, lumaSe.w));
        half lumaMax = max(max(lumaNw.w, lumaSw.w), max(lumaNe.w, lumaSe.w));
    #else
        half lumaMin = min(min(lumaNw.y, lumaSw.y), min(lumaNe.y, lumaSe.y));
        half lumaMax = max(max(lumaNw.y, lumaSw.y), max(lumaNe.y, lumaSe.y));
    #endif        
    rgby2 = (rgby2 + rgby1) * 0.5;
/*--------------------------------------------------------------------------*/
// (12)
    #if (FXAA_GREEN_AS_LUMA == 0)
        bool twoTapLt = rgby2.w < lumaMin;
        bool twoTapGt = rgby2.w > lumaMax;
    #else
        bool twoTapLt = rgby2.y < lumaMin;
        bool twoTapGt = rgby2.y > lumaMax;
    #endif
/*--------------------------------------------------------------------------*/
// (13)
    if(twoTapLt || twoTapGt) rgby2 = rgby1;
/*--------------------------------------------------------------------------*/
    return rgby2; }
/*==========================================================================*/
#endif



/*============================================================================

       FXAA3 CONSOLE - OPTIMIZED PS3 PIXEL SHADER (WITH EARLY EXIT)

==============================================================================
The code mostly matches the assembly.
I have a feeling that 14 cycles is possible, but was not able to get there.
Might have to increase register count to get full performance.
Note this shader does not use perspective interpolation.

Use the following cgc options,

 --fenable-bx2 --fastmath --fastprecision --nofloatbindings

Use of FXAA_GREEN_AS_LUMA currently adds a cycle (16 clks).
Will look at fixing this for FXAA 3.12.
------------------------------------------------------------------------------
                             NVSHADERPERF OUTPUT
------------------------------------------------------------------------------
For reference and to aid in debug, output of NVShaderPerf should match this,

Shader to schedule:
  0: texpkb h0.w(TRUE), v5.zyxx, #0
  2: addh h2.y(TRUE), h0.w, constant(0.001953, 0.000000, 0.000000, 0.000000).x
  4: texpkb h1.w(TRUE), v5.xwxx, #0
  6: addh h0.x(TRUE), h1.w, -h2.y
  7: texpkb h2.w(TRUE), v5.zwzz, #0
  9: minh h4.w(TRUE), h2.y, h2
 10: maxh h5.x(TRUE), h2.y, h2.w
 11: texpkb h0.w(TRUE), v5, #0
 13: addh h3.w(TRUE), -h0, h0.x
 14: addh h0.x(TRUE), h0.w, h0
 15: addh h0.z(TRUE), -h2.w, h0.x
 16: addh h0.x(TRUE), h2.w, h3.w
 17: minh h5.y(TRUE), h0.w, h1.w
 18: nrmh h2.xz(TRUE), h0_n
 19: minh_m8 h2.w(TRUE), |h2.x|, |h2.z|
 20: divx h4.xy(TRUE), h2_n.xzzw, h2_n.w
 21: movr r1.zw(TRUE), v4.xxxy
 22: maxh h2.w(TRUE), h0, h1
 23: fenct TRUE
 24: madr r0.xy(TRUE), -h2.xzzw, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zwzz, r1.zwzz
 26: texpkb h0(TRUE), r0, #0
 28: maxh h5.x(TRUE), h2.w, h5
 29: minh h5.w(TRUE), h5.y, h4
 30: madr r1.xy(TRUE), h2.xzzw, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).zwzz, r1.zwzz
 32: texpkb h2(TRUE), r1, #0
 34: addh_d2 h2(TRUE), h0, h2
 35: texpkb h1(TRUE), v4, #0
 37: maxh h5.y(TRUE), h5.x, h1.w
 38: minh h4.w(TRUE), h1, h5
 39: madr r0.xy(TRUE), -h4, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz
 41: texpkb h0(TRUE), r0, #0
 43: addh_m8 h5.z(TRUE), h5.y, -h4.w
 44: madr r2.xy(TRUE), h4, constant(cConst5.x, cConst5.y, cConst5.z, cConst5.w).xyxx, r1.zwzz
 46: texpkb h3(TRUE), r2, #0
 48: addh_d2 h0(TRUE), h0, h3
 49: addh_d2 h3(TRUE), h0, h2
 50: movh h0(TRUE), h3
 51: slth h3.x(TRUE), h3.w, h5.w
 52: sgth h3.w(TRUE), h3, h5.x
 53: addx.c0 rc(TRUE), h3.x, h3
 54: slth.c0 rc(TRUE), h5.z, h5
 55: movh h0(c0.NE.w), h2
 56: movh h0(c0.NE.x), h1

IPU0 ------ Simplified schedule: --------
Pass |  Unit  |  uOp |  PC:  Op
-----+--------+------+-------------------------
   1 | SCT0/1 |  mov |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;
     |    TEX |  txl |   0:  TXLr h0.w, g[TEX1].zyxx, const.xxxx, TEX0;
     |   SCB0 |  add |   2:  ADDh h2.y, h0.-w--, const.-x--;
     |        |      |
   2 | SCT0/1 |  mov |   4:  TXLr h1.w, g[TEX1].xwxx, const.xxxx, TEX0;
     |    TEX |  txl |   4:  TXLr h1.w, g[TEX1].xwxx, const.xxxx, TEX0;
     |   SCB0 |  add |   6:  ADDh h0.x, h1.w---,-h2.y---;
     |        |      |
   3 | SCT0/1 |  mov |   7:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;
     |    TEX |  txl |   7:  TXLr h2.w, g[TEX1].zwzz, const.xxxx, TEX0;
     |   SCB0 |  max |  10:  MAXh h5.x, h2.y---, h2.w---;
     |   SCB1 |  min |   9:  MINh h4.w, h2.---y, h2;
     |        |      |
   4 | SCT0/1 |  mov |  11:  TXLr h0.w, g[TEX1], const.xxxx, TEX0;
     |    TEX |  txl |  11:  TXLr h0.w, g[TEX1], const.xxxx, TEX0;
     |   SCB0 |  add |  14:  ADDh h0.x, h0.w---, h0;
     |   SCB1 |  add |  13:  ADDh h3.w,-h0, h0.---x;
     |        |      |
   5 |   SCT0 |  mad |  16:  ADDh h0.x, h2.w---, h3.w---;
     |   SCT1 |  mad |  15:  ADDh h0.z,-h2.--w-, h0.--x-;
     |   SCB0 |  min |  17:  MINh h5.y, h0.-w--, h1.-w--;
     |        |      |
   6 |   SCT1 |  mov |  18:  NRMh h2.xz, h0;
     |    SRB |  nrm |  18:  NRMh h2.xz, h0;
     |   SCB1 |  min |  19:  MINh*8 h2.w, |h2.---x|, |h2.---z|;
     |        |      |
   7 |   SCT0 |  div |  20:  DIVx h4.xy, h2.xz--, h2.ww--;
     |   SCT1 |  mov |  21:  MOVr r1.zw, g[TEX0].--xy;
     |   SCB1 |  max |  22:  MAXh h2.w, h0, h1;
     |        |      |
   8 |   SCT0 |  mad |  24:  MADr r0.xy,-h2.xz--, const.zw--, r1.zw--;
     |   SCT1 |  mov |  26:  TXLr h0, r0, const.xxxx, TEX0;
     |    TEX |  txl |  26:  TXLr h0, r0, const.xxxx, TEX0;
     |   SCB0 |  max |  28:  MAXh h5.x, h2.w---, h5;
     |   SCB1 |  min |  29:  MINh h5.w, h5.---y, h4;
     |        |      |
   9 |   SCT0 |  mad |  30:  MADr r1.xy, h2.xz--, const.zw--, r1.zw--;
     |   SCT1 |  mov |  32:  TXLr h2, r1, const.xxxx, TEX0;
     |    TEX |  txl |  32:  TXLr h2, r1, const.xxxx, TEX0;
     | SCB0/1 |  add |  34:  ADDh/2 h2, h0, h2;
     |        |      |
  10 | SCT0/1 |  mov |  35:  TXLr h1, g[TEX0], const.xxxx, TEX0;
     |    TEX |  txl |  35:  TXLr h1, g[TEX0], const.xxxx, TEX0;
     |   SCB0 |  max |  37:  MAXh h5.y, h5.-x--, h1.-w--;
     |   SCB1 |  min |  38:  MINh h4.w, h1, h5;
     |        |      |
  11 |   SCT0 |  mad |  39:  MADr r0.xy,-h4, const.xy--, r1.zw--;
     |   SCT1 |  mov |  41:  TXLr h0, r0, const.zzzz, TEX0;
     |    TEX |  txl |  41:  TXLr h0, r0, const.zzzz, TEX0;
     |   SCB0 |  mad |  44:  MADr r2.xy, h4, const.xy--, r1.zw--;
     |   SCB1 |  add |  43:  ADDh*8 h5.z, h5.--y-,-h4.--w-;
     |        |      |
  12 | SCT0/1 |  mov |  46:  TXLr h3, r2, const.xxxx, TEX0;
     |    TEX |  txl |  46:  TXLr h3, r2, const.xxxx, TEX0;
     | SCB0/1 |  add |  48:  ADDh/2 h0, h0, h3;
     |        |      |
  13 | SCT0/1 |  mad |  49:  ADDh/2 h3, h0, h2;
     | SCB0/1 |  mul |  50:  MOVh h0, h3;
     |        |      |
  14 |   SCT0 |  set |  51:  SLTh h3.x, h3.w---, h5.w---;
     |   SCT1 |  set |  52:  SGTh h3.w, h3, h5.---x;
     |   SCB0 |  set |  54:  SLThc0 rc, h5.z---, h5;
     |   SCB1 |  add |  53:  ADDxc0_s rc, h3.---x, h3;
     |        |      |
  15 | SCT0/1 |  mul |  55:  MOVh h0(NE0.wwww), h2;
     | SCB0/1 |  mul |  56:  MOVh h0(NE0.xxxx), h1;
 
Pass   SCT  TEX  SCB
  1:   0% 100%  25%
  2:   0% 100%  25%
  3:   0% 100%  50%
  4:   0% 100%  50%
  5:  50%   0%  25%
  6:   0%   0%  25%
  7: 100%   0%  25%
  8:   0% 100%  50%
  9:   0% 100% 100%
 10:   0% 100%  50%
 11:   0% 100%  75%
 12:   0% 100% 100%
 13: 100%   0% 100%
 14:  50%   0%  50%
 15: 100%   0% 100%

MEAN:  26%  60%  56%

Pass   SCT0  SCT1   TEX  SCB0  SCB1
  1:    0%    0%  100%  100%    0%
  2:    0%    0%  100%  100%    0%
  3:    0%    0%  100%  100%  100%
  4:    0%    0%  100%  100%  100%
  5:  100%  100%    0%  100%    0%
  6:    0%    0%    0%    0%  100%
  7:  100%  100%    0%    0%  100%
  8:    0%    0%  100%  100%  100%
  9:    0%    0%  100%  100%  100%
 10:    0%    0%  100%  100%  100%
 11:    0%    0%  100%  100%  100%
 12:    0%    0%  100%  100%  100%
 13:  100%  100%    0%  100%  100%
 14:  100%  100%    0%  100%  100%
 15:  100%  100%    0%  100%  100%

MEAN:   33%   33%   60%   86%   80%
Fragment Performance Setup: Driver RSX Compiler, GPU RSX, Flags 0x5
Results 15 cycles, 3 r regs, 800,000,000 pixels/s
============================================================================*/
#if (FXAA_PS3 == 1) && (FXAA_EARLY_EXIT == 1)
/*--------------------------------------------------------------------------*/
#pragma regcount 7
#pragma disablepc all
#pragma option O2
#pragma option OutColorPrec=fp16
#pragma texformat default RGBA8
/*==========================================================================*/
half4 FxaaPixelShader(
    // See FXAA Quality FxaaPixelShader() source for docs on Inputs!
    FxaaFloat2 pos,
    FxaaFloat4 fxaaConsolePosPos,
    FxaaTex tex,
    FxaaTex fxaaConsole360TexExpBiasNegOne,
    FxaaTex fxaaConsole360TexExpBiasNegTwo,
    FxaaFloat2 fxaaQualityRcpFrame,
    FxaaFloat4 fxaaConsoleRcpFrameOpt,
    FxaaFloat4 fxaaConsoleRcpFrameOpt2,
    FxaaFloat4 fxaaConsole360RcpFrameOpt2,
    FxaaFloat fxaaQualitySubpix,
    FxaaFloat fxaaQualityEdgeThreshold,
    FxaaFloat fxaaQualityEdgeThresholdMin,
    FxaaFloat fxaaConsoleEdgeSharpness,
    FxaaFloat fxaaConsoleEdgeThreshold,
    FxaaFloat fxaaConsoleEdgeThresholdMin,
    FxaaFloat4 fxaaConsole360ConstDir
) {
/*--------------------------------------------------------------------------*/
// (1)
    half4 rgbyNe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zy, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        half lumaNe = rgbyNe.w + half(1.0/512.0);
    #else
        half lumaNe = rgbyNe.y + half(1.0/512.0);
    #endif
/*--------------------------------------------------------------------------*/
// (2)
    half4 lumaSw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xw, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        half lumaSwNegNe = lumaSw.w - lumaNe;
    #else
        half lumaSwNegNe = lumaSw.y - lumaNe;
    #endif
/*--------------------------------------------------------------------------*/
// (3)
    half4 lumaNw = h4tex2Dlod(tex, half4(fxaaConsolePosPos.xy, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        half lumaMaxNwSw = max(lumaNw.w, lumaSw.w);
        half lumaMinNwSw = min(lumaNw.w, lumaSw.w);
    #else
        half lumaMaxNwSw = max(lumaNw.y, lumaSw.y);
        half lumaMinNwSw = min(lumaNw.y, lumaSw.y);
    #endif
/*--------------------------------------------------------------------------*/
// (4)
    half4 lumaSe = h4tex2Dlod(tex, half4(fxaaConsolePosPos.zw, 0, 0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        half dirZ =  lumaNw.w + lumaSwNegNe;
        half dirX = -lumaNw.w + lumaSwNegNe;
    #else
        half dirZ =  lumaNw.y + lumaSwNegNe;
        half dirX = -lumaNw.y + lumaSwNegNe;
    #endif
/*--------------------------------------------------------------------------*/
// (5)
    half3 dir;
    dir.y = 0.0;
    #if (FXAA_GREEN_AS_LUMA == 0)
        dir.x =  lumaSe.w + dirX;
        dir.z = -lumaSe.w + dirZ;
        half lumaMinNeSe = min(lumaNe, lumaSe.w);
    #else
        dir.x =  lumaSe.y + dirX;
        dir.z = -lumaSe.y + dirZ;
        half lumaMinNeSe = min(lumaNe, lumaSe.y);
    #endif
/*--------------------------------------------------------------------------*/
// (6)
    half4 dir1_pos;
    dir1_pos.xy = normalize(dir).xz;
    half dirAbsMinTimes8 = min(abs(dir1_pos.x), abs(dir1_pos.y)) * half(FXAA_CONSOLE__PS3_EDGE_SHARPNESS);
/*--------------------------------------------------------------------------*/
// (7)
    half4 dir2_pos;
    dir2_pos.xy = clamp(dir1_pos.xy / dirAbsMinTimes8, half(-2.0), half(2.0));
    dir1_pos.zw = pos.xy;
    dir2_pos.zw = pos.xy;
    #if (FXAA_GREEN_AS_LUMA == 0)
        half lumaMaxNeSe = max(lumaNe, lumaSe.w);
    #else
        half lumaMaxNeSe = max(lumaNe, lumaSe.y);
    #endif
/*--------------------------------------------------------------------------*/
// (8)
    half4 temp1N;
    temp1N.xy = dir1_pos.zw - dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;
    temp1N = h4tex2Dlod(tex, half4(temp1N.xy, 0.0, 0.0));
    half lumaMax = max(lumaMaxNwSw, lumaMaxNeSe);
    half lumaMin = min(lumaMinNwSw, lumaMinNeSe);
/*--------------------------------------------------------------------------*/
// (9)
    half4 rgby1;
    rgby1.xy = dir1_pos.zw + dir1_pos.xy * fxaaConsoleRcpFrameOpt.zw;
    rgby1 = h4tex2Dlod(tex, half4(rgby1.xy, 0.0, 0.0));
    rgby1 = (temp1N + rgby1) * 0.5;
/*--------------------------------------------------------------------------*/
// (10)
    half4 rgbyM = h4tex2Dlod(tex, half4(pos.xy, 0.0, 0.0));
    #if (FXAA_GREEN_AS_LUMA == 0)
        half lumaMaxM = max(lumaMax, rgbyM.w);
        half lumaMinM = min(lumaMin, rgbyM.w);
    #else
        half lumaMaxM = max(lumaMax, rgbyM.y);
        half lumaMinM = min(lumaMin, rgbyM.y);
    #endif
/*--------------------------------------------------------------------------*/
// (11)
    half4 temp2N;
    temp2N.xy = dir2_pos.zw - dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;
    temp2N = h4tex2Dlod(tex, half4(temp2N.xy, 0.0, 0.0));
    half4 rgby2;
    rgby2.xy = dir2_pos.zw + dir2_pos.xy * fxaaConsoleRcpFrameOpt2.zw;
    half lumaRangeM = (lumaMaxM - lumaMinM) / FXAA_CONSOLE__PS3_EDGE_THRESHOLD;
/*--------------------------------------------------------------------------*/
// (12)
    rgby2 = h4tex2Dlod(tex, half4(rgby2.xy, 0.0, 0.0));
    rgby2 = (temp2N + rgby2) * 0.5;
/*--------------------------------------------------------------------------*/
// (13)
    rgby2 = (rgby2 + rgby1) * 0.5;
/*--------------------------------------------------------------------------*/
// (14)
    #if (FXAA_GREEN_AS_LUMA == 0)
        bool twoTapLt = rgby2.w < lumaMin;
        bool twoTapGt = rgby2.w > lumaMax;
    #else
        bool twoTapLt = rgby2.y < lumaMin;
        bool twoTapGt = rgby2.y > lumaMax;
    #endif
    bool earlyExit = lumaRangeM < lumaMax;
    bool twoTap = twoTapLt || twoTapGt;
/*--------------------------------------------------------------------------*/
// (15)
    if(twoTap) rgby2 = rgby1;
    if(earlyExit) rgby2 = rgbyM;
/*--------------------------------------------------------------------------*/
    return rgby2; }
/*==========================================================================*/
#endif

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 rcpFrame = vec2(1.0) / iResolution.xy;
    fragColor =
        FxaaPixelShader(fragCoord / iResolution.xy,
                        vec4(0.0),
                        iChannel0,
                        iChannel0,
                        iChannel0,
                        rcpFrame,
                        vec4(0.0),
                        vec4(0.0),
                        vec4(0.0),
                        0.75, // Sub-pixel aliasing removal (affects sharpness)
                        0.166, // Edge threshold
                        0.0833, // Min edge threshold (trims alg from processing darks)
                        0.0,
                        0.0,
                        0.0,
						vec4(0.0));
}

#else

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord / iResolution.xy;
    fragColor = texture(iChannel0, uv);
}

#endif


void main() {
	vec4 fc;
	mainImage(fc,vec2(gl_FragCoord.x,gl_FragCoord.y));
	glFragColor=fc;
}
#version 300 es
#ifdef GL_ES
 precision highp float;
#endif
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_texture1;
uniform float u_time;
out vec4 glFragColor;

#define iTime u_time
#define iResolution u_resolution
#define iChannel0 u_texture1
#define iMouse u_mouse

// License Creative Commons Attribution-NonCommercial-ShareAlike
// original source github.com/danilw
void mainImage(out vec4 o,vec2 u)
{
    o =  mix(o = texture(iChannel0, u /= iResolution.xy),
             vec4 ( dot(o,vec4(.3,.59,.11,0)) ), 1.); //1-0 anim
}


void main() {
	vec4 ret;
	mainImage(ret,gl_FragCoord.xy);
	glFragColor=ret;
	glFragColor.a=1.;
}
#version 300 es
#ifdef GL_ES
 precision highp float;
#endif
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_texture1;
uniform float u_time;

uniform int shape_type;
uniform vec2 shape_size;
uniform vec2 shape_pos;
uniform float shape_rotate_an;

out vec4 glFragColor;

#define iTime u_time
#define iResolution u_resolution
#define iChannel0 u_texture1
#define iMouse u_mouse

// License Creative Commons Attribution-NonCommercial-ShareAlike
// original source github.com/danilw
#define PI (4.0 * atan(1.0))
#define TWO_PI PI*2.
#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))

#define B_TRI 0
#define B_RECT 1
#define B_CIRCLE 2

#define type_RECT_angles  4
#define type_CIRCLE_angles  320
#define type_TRI_angles  3

float shape_uni(vec2 uv, int N)
{
  float color = 0.0;
  float d = 0.0;
  float a = atan(uv.x,uv.y)+PI;
  float rx = TWO_PI/float(N);
  d = cos(floor(.5+a/rx)*rx-a)*length(uv);
  return (d);
}

// or IQ SDF http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
float shape_RECT( in vec2 p, in vec2 b)
{
    vec2 d = abs(p)-b;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)+0.5;
}

float shape_CIRCLE( vec2 p, float r )
{
  return length(p) - r+0.5;
}

float shape_TRI(  in vec2 p )
{
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;
    p.x -= clamp( p.x, -2.0, 0.0 );
    return -length(p)*sign(p.y)+0.5;
}

//uni
float shape_u(vec2 uv,int shape_type){
	int angles=0;
	if(shape_type==B_RECT)angles=type_RECT_angles;
	if(shape_type==B_CIRCLE)angles=type_CIRCLE_angles;
	if(shape_type==B_TRI){uv*=2.;angles=type_TRI_angles;}
	return shape_uni(uv,angles);
}

//SDF
float shape(vec2 uv,int shape_type){
	if(shape_type==B_RECT)return shape_RECT(uv,vec2(.5));
	if(shape_type==B_CIRCLE)return shape_CIRCLE(uv,.5);
	if(shape_type==B_TRI)return shape_TRI(uv*2.);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 res = iResolution.xy / iResolution.y;
    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;
    uv+=shape_pos.xy/iResolution.y-res/2.; //to box2d coords
    uv*=iResolution.y/shape_size.y;
    uv*=MD(-shape_rotate_an);
    
    float d= shape(uv,shape_type);
    //if(d>0.52)discard;

	fragColor = vec4(vec3(1.),smoothstep(0.6,0.4,d));

}

void main() {
	vec4 ret;
	mainImage(ret,gl_FragCoord.xy);
	glFragColor=ret;
}
#version 300 es
#ifdef GL_ES
 precision highp float;
#endif
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_texture1;
uniform float u_time;
uniform float u_rtime;

uniform int shape_type;
uniform int color_t;
uniform float ppower;
uniform float ajcd;
uniform float ajcd2;
uniform int shape_tile;
uniform vec2 shape_size;
uniform vec2 shape_pos;
uniform float shape_rotate_an;
uniform float shape_rotate_Urot;

out vec4 glFragColor;

#define iTime u_time
#define iResolution u_resolution
#define iChannel0 u_texture1
#define iMouse u_mouse

// License Creative Commons Attribution-NonCommercial-ShareAlike
// original source github.com/danilw

#define PI (4.0 * atan(1.0))
#define TWO_PI PI*2.
#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))

#define B_TRI 0
#define B_RECT 1
#define B_CIRCLE 2

#define TILE_SDF 0
#define TILE_0 1
#define TILE_1 2
#define TILE_2 3
#define TILE_2_2 4
#define TILE_3 5
#define TILE_3_2 6
#define TILE_4 7
#define TILE_4_2 8
#define TILE_SDF_SPAWN 9
#define TILE_PLAYER 10

#define type_RECT_angles  4
#define type_CIRCLE_angles  320
#define type_TRI_angles  3

//uni
float shape_uni(vec2 uv, int N)
{
  float color = 0.0;
  float d = 0.0;
  float a = atan(uv.x,uv.y)+PI;
  float rx = TWO_PI/float(N);
  d = cos(floor(.5+a/rx)*rx-a)*length(uv);
  return (d);
}

// or IQ SDF http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
float shape_RECT( in vec2 p, in vec2 b)
{
    vec2 d = abs(p)-b;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)+0.5;
}

float shape_CIRCLE( vec2 p, float r )
{
  return length(p) - r+0.5;
}

float shape_TRI(  in vec2 p )
{
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;
    p.x -= clamp( p.x, -2.0, 0.0 );
    return -length(p)*sign(p.y)+0.5;
}

//uni
float shape_u(vec2 uv,int shape_type){
	int angles=0;
	if(shape_type==B_RECT)angles=type_RECT_angles;
	if(shape_type==B_CIRCLE)angles=type_CIRCLE_angles;
	if(shape_type==B_TRI){uv*=2.;angles=type_TRI_angles;}
	return shape_uni(uv,angles);
}

//SDF
float shape(vec2 uv,int shape_type){
	if(shape_type==B_RECT)return shape_RECT(uv,vec2(.5));
	if(shape_type==B_CIRCLE)return shape_CIRCLE(uv,.5);
	if(shape_type==B_TRI)return shape_TRI(uv*2.);
}

vec4 tile_SDF(vec2 uv,float zv){
	vec2 res = iResolution.xy / iResolution.y;
    float d= shape(uv,shape_type);
    //if(d>0.6)discard;
    

    if(shape_type==B_TRI)zv+=4.; //because uv*2.for triangle
    vec3 col = vec3(1.0) - sign(d-0.5)*vec3(0.1,0.4,0.7);
	col *= 1.0 - exp(-2.0*abs(d-0.5));
	col *= 0.8 + 0.2*cos(iTime*2.+(max(120.0-10.*zv,1.))*(d-0.5));
	col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.025+0.015*zv,abs(d-0.5)) );
	float ss=smoothstep(0.6,0.47,d);
	return vec4(col*ss, ss);
	
}

const vec3 white = vec3(0xdc, 0xe0, 0xd1) / float(0xff);
const vec3 dark = vec3(0x1a, 0x13, 0x21) / float(0xff);

vec3 green = vec3(0x7f, 0xbe, 0x20) / float(0xff);
vec3 green_l = vec3(0x92, 0xdb, 0x26) / float(0xff);
const vec3 rep_gr = vec3(0xe9, 0xdf, 0xc3) / float(0xff);

vec3 ground1 = vec3(0xce, 0x98, 0x69) / float(0xff);
vec3 ground2 = vec3(0xca, 0x8f, 0x5b) / float(0xff);
vec3 ground3 = vec3(0xc1, 0x7f, 0x41) / float(0xff);

//http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm

float ndot(vec2 a, vec2 b) {
    return a.x * b.x - a.y * b.y;
}

float sdRhombus_o(in vec2 p, in vec2 b) {
    vec2 q = abs(p);

    float h = clamp((-2.0 * ndot(q, b) + ndot(b, b)) / dot(b, b), -1.0, 1.0);
    float d = length(q - 0.5 * b * vec2(1.0 - h, 1.0 + h));
    d *= sign(q.x * b.y + q.y * b.x - b.x * b.y);

    return d + 0.5;
}

float sdRhombus(in vec2 p, in vec2 b) {
    if (p.y < 0.)return 1.;
    vec2 q = abs(p);

    float h = clamp((-2.0 * ndot(q, b) + ndot(b, b)) / dot(b, b), -1.0, 1.0);
    float d = length(q - 0.5 * b * vec2(1.0 - h, 1.0 + h));
    d *= sign(q.x * b.y + q.y * b.x - b.x * b.y);

    return d + 0.5;
}

float w1(vec2 p, float zv) {
    vec2 res = iResolution.xy / iResolution.y;
    p.y *= 1.1;
    float uvi = 1. / 3.;
    p.y += (uvi / 1.2)*1.2;
    if (p.y > uvi / 2.)p.y += uvi / 2.;
    bool bp = mod(p.y + uvi / 10., uvi * 2.) >= uvi;
    if (bp) {
        p.x += uvi / 2.;
    }
    p.x = abs(p.x) - uvi;


    p.y = mod(p.y + uvi / 10., uvi);

    if (bp) {
        p.y = uvi - abs(p.y);
    }

    p *= 3.;
    float d = sdRhombus((p + vec2(uvi * 3., 0.)), vec2(0.5, 0.5));
    d = min(d, sdRhombus(p, vec2(0.5, 0.5)));
    d = min(d, sdRhombus(p - vec2(uvi * 3., 0.), vec2(0.5, 0.5)));
    return 1. - smoothstep(0.0, 0.025 + 0.015 * zv, (d - 0.5));
}

float w2(vec2 p, float zv) {
    vec2 res = iResolution.xy / iResolution.y;
    p.y *= 1.1;
    float uvi = 1. / 3.;
    p.y += -(uvi / 1.2)*1.2;
    if ((p.y) > uvi / 3.5)return 1.;
    if ((p.y)<-uvi / 3.5)return 0.;
    p.y += -(uvi / 1.2) / 2.;
    p.x += uvi / 2.;
    p.x = abs(p.x) - uvi;


    p.y = mod(p.y + uvi / 10., uvi);
    p.y = uvi - abs(p.y);

    p *= 3.;
    float d = sdRhombus((p + vec2(uvi * 3., 0.)), vec2(0.5, 0.5));
    d = min(d, sdRhombus(p, vec2(0.5, 0.5)));
    d = min(d, sdRhombus(p - vec2(uvi * 3., 0.), vec2(0.5, 0.5)));
    return 1. - smoothstep(0.0, 0.025 + 0.015 * zv, (d - 0.5));
}

float w2_2(vec2 p, float zv) {
    vec2 res = iResolution.xy / iResolution.y;

    p.x += 0.035;
    p.y += 0.03;
    p.y *= 1.1;
    float uvi = 1. / 3.;
    p.y += -(uvi / 1.2)*1.2;
    p.y += -(uvi / 1.2) / 2.;
    vec2 op = p;
    bool bp = mod(p.y + uvi / 10., uvi * 2.) >= uvi;



    p.y = mod(p.y + uvi / 10., uvi);

    //if(bp)
    {
        p.y = uvi - abs(p.y);
    }

    p *= 3.;
    float d = 1.; //sdRhombus( (p+vec2(uvi*3.,0.)), vec2(0.5,0.5)) ;
    d = min(d, sdRhombus_o(op * 3. + vec2((uvi)*3., -(uvi / 3. * 3.)*1.2), vec2(0.5, 0.5)));
    d = min(d, sdRhombus_o(op * 3. + vec2((uvi + uvi / 2.)*3., ((uvi / 12.)*3.)*1.2), vec2(0.5, 0.5)));
    //d = min(d,sdRhombus( p, vec2(0.5,0.5) ));
    //d = min(d,sdRhombus( p-vec2(uvi*3.,0.), vec2(0.5,0.5) ));
    return 1. - smoothstep(0.0, 0.025 + 0.015 * zv, (d - 0.5));
}

float w3(vec2 p, float zv) {
    float d = 0.;
    p.y += -0.47;
    d = smoothstep(0.0, 0.0025 + 0.015 * zv, p.y);
    return d;
}

float w4(vec2 p, float zv) {
    float d = 0.;
    p += -0.2879+0.0005*zv;;
    p.y *= 1.105;
    p *= 3.;
    d = sdRhombus_o(p, vec2(0.5, 0.5));
    return (1. - smoothstep(0.0, 0.025 + 0.015 * zv, (d - 0.5)))*1.;
}

float w5(vec2 p, float zv) {
    float d = 0.;
    p.x += -0.375-0.005*zv;
    p.y += -0.178;
    p.y *= 1.1;
    p *= 2.;
    d = sdRhombus_o(p, vec2(0.5, 0.5));
    return 1. - smoothstep(0.0, 0.025 / 2. + 0.015 * zv / 2., (d - 0.5));
}

vec2 box(vec2 uv, float zv) {
    float d = shape_RECT(uv, vec2(.5));
    return vec2(1.-smoothstep(-0.0-0.005*zv,0.015+0.015*zv,(d-0.5)),1.-smoothstep(-0.0-0.015*zv,0.025+0.015*zv,(d-0.5)));
}

vec4 tile0(vec2 uv, float zv) {
    vec4 fragColor;
    vec2 res = iResolution.xy / iResolution.y;


    vec2 ouv = uv;


    float d = w1(uv, zv);


    fragColor = vec4(d);

    vec3 col = ground1;
    col = mix(col, ground2, d);

    fragColor = vec4(col, 1.);

    return fragColor;

}

vec4 tile1(vec2 uv, float zv) {
    vec4 fragColor;
    vec2 res = iResolution.xy / iResolution.y;

    vec2 ouv = uv;

    float d = w1(uv, zv);
    float d2 = w2(uv, zv);
    float d3 = step(1. / 9., uv.y)*(1. - (d2 + d));
    float d4 = w3(uv, zv);
    d3 = max(0., d3);

    fragColor = vec4(d);

    vec3 col = ground1;
    col = mix(col, ground2, d);
    col = mix(col, ground3, d3);
    col = mix(col, green, d2);
    col = mix(col, green_l, d4);

    fragColor = vec4(col, 1.)*smoothstep(0.55,0.52-0.01*zv,uv.y);
    return fragColor;

}

vec4 tile3(vec2 uv, float zv) {
    vec4 fragColor;
    vec2 res = iResolution.xy / iResolution.y;

    vec2 ouv = uv;

    float d = w1(uv, zv);
    float d2 = w2_2(uv, zv)*(smoothstep(-0.235+ 0.001*zv, -.235 - 0.001*zv, uv.x)) ;
    float d3 = (smoothstep(-0.24+ 0.005*zv, -.24 - 0.005*zv, uv.x) 
                * smoothstep(0.64-0.005*zv, .64+0.005*zv, -uv.x + uv.y * 1.1))*(1. - (d2 + d));
    float d4 = w3(uv, zv);
    d3 = max(0., d3);

    fragColor = vec4(d);

    vec3 col = ground1;
    col = mix(col, ground2, d);
    col = mix(col, ground3, d3);
    col = mix(col, green, d2);

    fragColor = vec4(col, 1.)*smoothstep(0.55,0.52-0.01*zv,uv.y);
    return fragColor;

}

vec4 tile4(vec2 uv, float zv) {
    vec4 fragColor;

    vec2 res = iResolution.xy / iResolution.y;
    vec2 ouv = uv;

    float d = w1(uv, zv);
    float d2 = 0. * w2(uv, zv);
    d2 = max(d2, w2(vec2(uv.y, uv.x * (0.77777) + 0.05), zv));
    float d3 = step(1. / 9., uv.y)*(1. - (d2 + d));
    float d4 = 0. * w3(uv, zv);

    float d5 = w5(uv + vec2(-0.1, 0.05), zv);
    d5 = max(d5, w5(uv + vec2(-0.1, -0.29), zv));
    d5 = max(d5, w5(uv + vec2(-0.1, 0.39), zv)); //ZV !!!!
    d5 *= smoothstep(0.0, 0.025 + 0.015 * 1., (uv.x - 0.24)*2.)*(1. - (d2));

    d4 = max(d4, w3(vec2(uv.y, uv.x  - 0.01), zv));
    d3 = max(0., d3);

    fragColor = vec4(d);



    vec3 col = ground1;
    col = mix(col, ground2, d);
    col = mix(col, green, d2);
    col = mix(col, green_l, d4);
    col = mix(col, ground3, d5);

    fragColor = vec4(col, 1.);

    return fragColor;

}

vec4 tile2(vec2 uv, float zv) {
    vec2 res = iResolution.xy / iResolution.y;
    vec2 ouv = uv;

    float d = w1(uv, zv);
    float d2 = w2(uv, zv);
    d2 = max(d2, w2(vec2(uv.y, uv.x * (0.77777) + 0.05), zv));
    d2 = max(w4(uv,  zv), d2);
    float d3 = step(1. / 9., uv.y)*(1. - (d2 + d));
    float d4 = w3(uv, zv);
    float d5 = w5(uv, zv);
    d5 = max(d5, w5(uv + vec2(-0.1, 0.39), zv) *
            smoothstep(0.0, 0.025 + 0.015 * zv, (uv.x - 0.24)*2.))*(1. - (d2));

    d4 = max(d4, w3(vec2(uv.y, uv.x  - 0.01), zv));
    d3 = max(0., d3);

    vec4 fragColor;



    vec3 col = ground1;
    col = mix(col, ground2, d);
    col = mix(col, ground3, d3);
    col = mix(col, green, d2);
    col = mix(col, green_l, d4);
    col = mix(col, ground3, d5);

    fragColor = vec4(col, 1.)*smoothstep(0.55,0.52-0.01*zv,uv.y);

    return fragColor;

}

float spawn(vec2 uv){
    float iTime=mod(iTime,4.);
    if(iTime>2.) return 0.;
    float v=0.6*smoothstep(0.,2.,mod(iTime,2.));
    return smoothstep(v+0.001,v,abs(uv.x));
}


const vec3 white3 = vec3(0xd6, 0xdb, 0xd3) / float(0xff);
const vec3 pink = vec3(0xfe, 0x67, 0x63) / float(0xff);
const vec3 purp = vec3(0x49, 0x11, 0x9c) / float(0xff);


float sdLine( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

float line_time=0.8;

float square_ts=0.2;
float square_te=3.;

float circ1_ts=0.62;
float circ1_te=3.;

float circ2_ts=0.4;
float circ2_te=2.;

float circ3_ts=0.4;
float circ3_te=2.;

float circ4_ts=0.85;
float circ4_te=2.5;

float circ5_ts=01.85;
float circ5_te=2.5;

float circ6_ts=7.;
float circ6_te=7.5;

float timer(float timexs,float timexe,float timex){
    return smoothstep(timexs,timexe,timex);
}

float stimer(float timexs,float timexe,float timex){
    float v=timer(timexs, timexe, timex/2.);
    return cos(PI/2.-(PI/2.)*sin((PI/2.)*v));
}

float shape_RECT_rounded( in vec2 p, in float r , in vec2 b)
{
  return abs(shape_RECT(p,b)) - r;
}

float ranim(vec2 uv){
    uv*=MD(2.5);
    float af = atan(uv.x,uv.y);
    float r = length(uv);
    uv = vec2(af/TWO_PI,r);
    float av=-(-PI*1.3+TWO_PI*stimer(square_ts,square_te,iTime));
    float d=smoothstep(0.0+av,0.01+av,uv.x);
    return d;
}

float ranim2(vec2 uv){
    uv*=MD(-PI/2.);
    float af = atan(uv.x,uv.y);
    float r = length(uv);
    uv = vec2(af/TWO_PI,r);
    float av=(-PI*1.3+TWO_PI*stimer(circ1_ts,circ1_te,iTime));
    float d=smoothstep(0.01+av,0.0+av,uv.x);
    return d;
}

float ranim3(vec2 uv){
    uv*=MD(PI/2.);
    float af = atan(uv.x,uv.y);
    float r = length(uv);
    uv = vec2(af/TWO_PI,r);
    float av=-(-PI*1.3+TWO_PI*stimer(circ2_ts,circ2_te,iTime));
    float av_1=-(-PI*1.3+TWO_PI*stimer(circ2_ts,circ2_te+1.20,iTime));
    float av2=-(-PI*.73+0.85*TWO_PI*stimer(circ2_ts,circ2_te+-.20,iTime));
    float d=smoothstep(0.0+av,0.1+av,uv.x);
    d=d*smoothstep(01.520+av2,01.6201+av2,uv.x);
    d=min(d,smoothstep(PI/1.65+0.1,PI/1.65,uv.x));

    
    return d;
}

float ranim4(vec2 uv){
    uv*=MD(PI);
    float af = atan(uv.x,uv.y);
    float r = length(uv);
    uv = vec2(af/TWO_PI,r);
    float av=-(-PI*1.3+TWO_PI*stimer(circ2_ts,circ2_te,iTime));
    float d=smoothstep(0.0+av,0.01+av,uv.x);
    return d;
}

float ranim5(vec2 uv){
    uv*=MD(-PI);
    float af = atan(uv.x,uv.y);
    float r = length(uv);
    uv = vec2(af/TWO_PI,r);
    float av=-(-PI*1.3+TWO_PI*stimer(circ4_ts,circ4_te,iTime));
    float d=smoothstep(0.0+av,0.01+av,uv.x);
    d=d*smoothstep(0.01-av,-av,uv.x);
    return d;
}

float ranim6(vec2 uv){
    uv*=MD(-PI);
    float af = atan(uv.x,uv.y);
    float r = length(uv);
    uv = vec2(af/TWO_PI,r);
    float segm=mod((abs(uv.x-20.5))*6.,2.)*(mod((uv.x+20.5)*6.,2.));
    float d=segm*stimer(circ5_ts,circ5_te,iTime);
    return d;
}

float ranim7(vec2 uv){
    
    vec2 res = iResolution.xy / iResolution.y;
    float af = atan(uv.x,uv.y);
    float r = length(uv);
    uv = vec2(af/TWO_PI,r);
    float d;
    uv.x=mod(uv.x,(TWO_PI-0.28)/6.);
    float v=0.5*smoothstep(circ6_te,circ6_ts,iTime);
    return smoothstep(0.-v,0.1-v,uv.x)*smoothstep((TWO_PI-0.28)/6.+v,0.9+v,uv.x);
    
}




const float Power = 5.059;
const float Dumping = 100.0;
vec3 colx=vec3(.20, 0.725, 01.08);




vec3 hash3(vec3 p) {
	p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
			dot(p, vec3(269.5, 183.3, 246.1)),
			dot(p, vec3(113.5, 271.9, 124.6)));

	return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float noise(vec3 p) {
	vec3 i = floor(p);
	vec3 f = fract(p);

	vec3 u = f * f * (3.0 - 2.0 * f);

	float n0 = dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));
	float n1 = dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));
	float n2 = dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));
	float n3 = dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));
	float n4 = dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));
	float n5 = dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));
	float n6 = dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));
	float n7 = dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));

	float ix0 = mix(n0, n1, u.x);
	float ix1 = mix(n2, n3, u.x);
	float ix2 = mix(n4, n5, u.x);
	float ix3 = mix(n6, n7, u.x);

	float ret = mix(mix(ix0, ix1, u.y), mix(ix2, ix3, u.y), u.z) * 0.5 + 0.5;
	return ret * 2.0 - 1.0;
}



float snoise(vec3 uv)
{
	const vec3 s = vec3(1e0, 1e2, 1e3);
	
    float res=16.;
	uv *= res;
	vec3 uv0 = floor(mod(uv, res))*s;
	vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;
	
	vec3 f = fract(uv); f = f*f*(3.0-2.0*f);

	vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
		      	  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);

	vec4 r = fract(sin(v*1e-1)*1e3);
	float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
	
	r = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);
	float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);
	
	return mix(r0, r1, f.z)*2.-1.;
}


float circle( in vec2 uv, float r1, float r2,vec2 ab)
{
    float t = r1-r2;
    float r = r1;    
    //return smoothstep(ab.x,ab.y, abs((uv.y) - r) - t/10.0);      // line
    return smoothstep(ab.x,ab.y, abs(length(uv) - r) - t/10.0);        
}

float circle2( in vec2 uv, float r1, float r2,vec2 ab)
{
    float t = r1-r2;
    float r = r1;    
    //return smoothstep(ab.x,ab.y, abs((uv.y) - r) - t/10.0);      // line
    return smoothstep(ab.x,ab.y, (length(uv) - r) - t/10.0);        
}



vec3 color(vec2 p) {
	vec3 coord = vec3(p*5., iTime * 0.25);
    coord=vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5)+ vec3(0.,iTime*.05, iTime*.01);
	float nx = abs(snoise(coord));
	float nx2 = 0.5 * abs(snoise(coord * 2.0));
	float nx3 = 0.25 * abs(snoise(coord * 4.0));
	float nx4 = 0.125 * abs(snoise(coord * 6.0));
    nx+=nx2+nx3+nx4;

    float vx=min(2.*circle(p*3.,1.,0.19,vec2(-0.25,0.8)),circle2(p*3.,.3,0.19,vec2(-0.24645,01.28)));
    float n=nx*vx;
	n *= (100.001 - Power);
	float dist =vx;
	n *= dist / pow(1.001 , Dumping);
    colx = 0.25*colx+colx*(0.5 + 0.5*cos(iTime+p.xyx+vec3(0,2,4)));
    colx*=.2/vec3(nx-nx2,-nx3+nx,-nx4+nx);
	vec3 col = colx / (n);
    //return col;
	return min(vec3(1.),pow(col, vec3(2.0)))*(1.-.9*vx); //-1.2 angleebug
}

vec4 mi(in vec2 uv) {
	vec3 col = color(uv);
	col = pow(col, vec3(0.24545));
    col=clamp(vec3(1.),vec3(0.),abs(col));
    
	return vec4(col, 1.0);
}



vec4 mixss(vec2 uv )
{
	
    float frequency = 3.0;
    
    float index = uv.x + iTime + uv.y;
    
    float red = sin(frequency * index + 0.0) * 0.5 + 0.5;
    float green = sin(frequency * index + 2.0) * 0.5 + 0.5;
    float blue = sin(frequency * index + 4.0) * 0.5 + 0.5;
    
    return vec4(red,green,blue,1.0);
}

vec4 player_mi(in vec2 uv, float zv )
{
    //float zoomx=1.2;
    //uv*=zoomx;
    
    float rot=-0.33;
    if(iTime>7.)rot+=-shape_rotate_Urot;
    float rot2=0.;
    if(iTime>7.)rot2=-shape_rotate_an;
    
    vec2 tuv=uv;
    float asx=sin(PI/2.-PI/2.*smoothstep(01.5,03.5+sin(-PI/2.*smoothstep(01.5,03.5,iTime)),iTime));
    uv.y+=01.4*smoothstep(01.2-sin(-PI/2.*smoothstep(02.,0.,iTime)),0.2,iTime);
    //uv+=0.5;
    //uv*=MD(-.52*asx);
    //uv+=vec2(-0.5,-0.5);
	float timerx=stimer(0.,line_time,iTime);
    float d=sdLine(tuv,vec2(-02.5*timerx,-0.5),vec2(02.5*timerx,-0.5));
    vec3 col ;
    
    float d2=shape_RECT_rounded(uv,0.1,vec2(0.4,0.4));
    float d3=shape_CIRCLE(uv,0.5);
    float d4=shape_CIRCLE(uv,0.43);
    float d5=shape_CIRCLE(uv,0.34);
    float d6=shape_CIRCLE(uv,0.07);
    float d7=shape_CIRCLE(uv,0.13);
    
    if(iTime<7.){
    col = mix(col,white3,(1.-ranim(uv))*(1.0-smoothstep(0.01,0.012,abs(d2-0.5))));
    
    col = mix(col,white3,ranim2(uv)*(1.0-smoothstep(0.01,0.012,abs(d3-0.5))));
    
    col = mix(col,pink,ranim3(uv*MD(rot))*(1.0-smoothstep(0.01,0.012,abs(d4-0.5))));
    
    col = mix(col,purp,ranim4(uv)*(1.0-smoothstep(0.01,0.012,abs(d5-0.5))));
    
    col = mix(col,purp,ranim5(uv)*(1.0-smoothstep(0.01,0.012,abs(d6-0.5))));
    
    col = mix(col,white3,ranim6(uv)*(1.0-smoothstep(0.01,0.012,abs(d7-0.5))));
    col*=smoothstep(-0.5,-0.49,tuv.y);
        
        if(iTime>4.){
            vec3 colx=col;
        col = white3*0.02/(abs(d3-0.5));
        col =max(col,ranim3(uv*MD(rot))*pink*0.03/(abs(d4-0.5)));
        col =max(col,purp*0.06/(abs(d5-0.5)));
        col =max(col,purp*0.08/(abs(d6-0.5)));
        col =max(col,(1.0-smoothstep(0.01,0.12,abs(d7-0.5)))*ranim6(uv)*(white3*0.03/(abs(d7-0.5))));
        col=min(max(vec3(0.),col),vec3(1.));
        col=  max(colx,col*(smoothstep(0.01+smoothstep(4.,6.5,iTime),
                                       0.+0.65*smoothstep(4.,6.5,iTime),length(uv))));
        col*=smoothstep(0.8,0.5,length(uv));
        }
        col = max(col,white3*(1.0-smoothstep(0.01,0.012,abs(d))));
        col=clamp(vec3(1.),vec3(0.),col);
    }
    else{
        vec3 cx=mi(tuv*.85).rgb*ppower;
        col =clamp(vec3(1.),vec3(0.),white3*0.02/(abs(d3+d5*cx.r/4.-0.5)))*ranim7(uv*MD(rot2));
        col =clamp(vec3(1.),vec3(0.),max(col,ranim3(uv*MD(rot))*pink*(0.03+0.03*ppower)/
                                         (abs(d4+cx.r/3.5-0.5))));
        col =max(col,clamp(vec3(1.),vec3(0.),(purp*step(uv.y,0.8*ajcd-0.4)+0.09/pink*step(uv.y,0.8*ajcd2-0.4))*0.06/(abs(d5-0.5))));
        col =max(col,purp*(0.08+cx/5.)/(abs(d6-d6*cx/10.-0.5)));
        col =max(col,(1.0-smoothstep(0.01,0.12,abs(d7-0.5)))*ranim6(uv*MD(rot2*2.8))*(cx+white3*0.03/(abs(d7-cx.r/5.-0.5))));
        col=clamp(vec3(1.),vec3(0.),col);
        col*=smoothstep(0.8,0.5,length(uv));
    }
    return vec4(col,max(max(col.r,col.g),col.b));
}




void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 res = iResolution.xy / iResolution.y;
    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;
    vec2 tuv=uv;
    uv+=(shape_pos.xy)/iResolution.y-res/2.; //to box2d coords
    
    uv*=iResolution.y/shape_size.y;
    float zv=1080./iResolution.y+50./shape_size.y; //zoom value
    zv+=2.;
    int shape_tile_l=shape_tile;
    if(shape_tile_l>100){shape_tile_l=shape_tile_l-100;green=green_l=mixss(tuv).rgb;ground1=ground1*green;ground2=ground2*green;ground3=ground3*green;}
    else
    if(shape_tile_l>10){shape_tile_l=shape_tile_l-10;green=green_l=rep_gr;}
    if(u_rtime<=15.)fragColor= vec4(0.);
    if((u_rtime<=15.+8.)&&(shape_tile_l!=TILE_PLAYER))fragColor= vec4(0.);
    switch(shape_tile_l){
	case TILE_SDF:uv*=MD(-shape_rotate_an);fragColor = tile_SDF(uv,zv);break;
	case TILE_0:fragColor = tile0(uv, zv);fragColor*=fragColor;break;
    case TILE_1:fragColor = tile1(uv, zv);fragColor*=fragColor;break;

    case TILE_2:fragColor = tile2(uv, zv);fragColor*=fragColor;break;
    case TILE_2_2:fragColor = tile2(vec2(-uv.x, uv.y), zv);fragColor*=fragColor;break; //2.2

    case TILE_3:fragColor = tile3(uv, zv);fragColor*=fragColor;break;
    case TILE_3_2:fragColor = tile3(vec2(-uv.x, uv.y), zv);fragColor*=fragColor;break; //3.2

    case TILE_4:fragColor = tile4(uv, zv);fragColor*=fragColor;break;
    case TILE_4_2:fragColor = tile4(vec2(-uv.x, uv.y), zv);fragColor*=fragColor;break; //4.2
    
    case TILE_SDF_SPAWN:uv*=MD(-shape_rotate_an);fragColor = tile_SDF(uv,zv);fragColor=mix(fragColor.brra*0.6*(step(mod(iTime,4.),2.)+smoothstep(2.,4.,mod(iTime,4.))),fragColor,spawn(uv));break;
    
    case TILE_PLAYER:fragColor = player_mi(uv, zv);fragColor*=fragColor;break;
	
	}
	
	if((u_rtime <= 15.+ 8. + 2.)&&(shape_tile_l!=TILE_PLAYER)){
		float ce = shape_CIRCLE(tuv, 2. * smoothstep(15.+ 8. + 0., 15.+ 8. + 2., u_rtime));
        ce = 1. - (smoothstep(0.0, 0.012, (ce - 0.5)));
        fragColor.rgb *= ce;
	}

}

void main() {
	vec4 ret;
	mainImage(ret,gl_FragCoord.xy);
	glFragColor=ret;
}
